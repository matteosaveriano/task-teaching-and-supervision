:- module(lazy_io).
:- export stream_to_lazy_list / 2.
:- export stream_to_list / 3.
:- export list_to_stream / 3.
:- comment(categories, ["Programming Utilities"]).
:- comment(summary, "Mapping between lists and I/O streams").
:- comment(author, "Joachim Schimpf").
:- comment(copyright, "Joachim Schimpf, Coninfer Ltd").
:- comment(date, "$Date: 2011/04/09 23:10:53 $").
:- comment(list_to_stream / 3, [summary : "Map a list to an output stream", args : ["Codes" : "A (possibly partial) list of character codes", "Stream" : "A stream handle", "Mode" : "One of the atoms 'incremental' or 'delayed'"], amode : (list_to_stream(?, +, +) is det), see_also : [stream_to_lazy_list / 2, open / 4, char_code / 2, string_list / 2], desc : html("<P>\r\n\tThis predicates maps a list of character codes to an output\r\n\tstream.  When list_to_stream/3 is called, the list Codes may\r\n\tbe uninstantiated, or it may be a partial list.  Once the list\r\n\tis terminated, and the Stream is closed, the file will reflect\r\n\tthe last state of the list.  As long as the stream is not\r\n\tclosed, the list may be arbitrarily extended, shortened on\r\n\tbacktracking, terminated, un-terminated on backtracking, etc. \r\n\tOnly once the stream is closed using close/1, is the stream\r\n\tcontents committed to reflect the list (provided the list has\r\n\tbeen terminated).  This behaviour is independent of the Mode\r\n\targument.\r\n</P><P>\r\n\tMode 'incremental' should be used if the list may become very long.\r\n\tIn this mode the list is copied into the stream incrementally, such\r\n\tthat the front of the list can be garbage collected.\r\n</P><P>\r\n\tMode 'delayed' may be slightly more efficient, since it copies the\r\n\tlist contents to the stream only once the list is terminated.  This\r\n\twill however use more memory, since the whole list needs to be held\r\n\tin memory until it is terminated.\r\n</P><P>\r\n\tThe Stream must be open in write-mode.  In addition it is advisable\r\n\tto set the delete_file(when_lost) option when opening - this will\r\n\thave the effect of eventually deleting the associated file in case\r\n\tthe stream is never explicitly closed.\r\n</P><P>\r\n\tIf the stream is closed without the list being terminated, the stream\r\n\tcontent is essentially undefined.  In practice, with 'incremental'\r\n\tmode the stream will reflect the partial list as it was when the\r\n\tstream was closed.  With 'delayed' mode, the stream will be empty\r\n\tor reflect an earlier terminated state that was backtracked over.\r\n</P>\r\n    "), eg : "\r\n    write_list(File, N, Code) :-\r\n\topen(File, write, Out, [delete_file(when_lost)]),\r\n\tlist_to_stream(Codes, Out, incremental),\r\n\t( for(_,1,N), foreach(Code,Codes), param(Code) do true ),\r\n\tclose(Out).\r\n    "]).
:- comment(stream_to_lazy_list / 2, [summary : "Map an input stream to a lazy list", args : ["Stream" : "A stream handle", "Codes" : "A variable or (possibly partial) list"], amode : (stream_to_lazy_list(+, ?) is semidet), see_also : [list_to_stream / 3, char_code / 2, string_list / 2], desc : html("<P>\r\n    \tThis predicate makes the content of Stream available as a list of\r\n\tcharacter codes, similar to reading the whole stream content into\r\n\ta list, and then using the list.  However, in this lazy version\r\n\tthe list is materialized in an incremental fashion, i.e.  only\r\n\twhen its elements are created by the list processing code, are\r\n\tthe character codes read from the stream and filled in.  For most\r\n\tpurposes, this lazy list can be used like a normal list, e.g. in\r\n\tparsing with DCGs.  The advantage of the lazy version is that at\r\n\tno time is it necessary to have the whole list in memory: the tail\r\n\tis created lazily from the stream, and the front will be garbage\r\n\tcollected when no longer needed.\r\n\t</P><P>\r\n\tThe stream must be open in read-mode.  The list will reflect the\r\n\tstream content starting from the position the stream is at when\r\n\tstream_to_lazy_list/2 is called.  The list will end with the last\r\n\tcharacter in the stream.  If the stream content changes while the\r\n\tlist is partly materialised, the list content is undefined.\r\n\t</P><P>\r\n\tThe stream should not be closed as long as it is possible to backtrack\r\n\tto a point between the call to stream_to_lazy_list/2 and the\r\n\ttermination of the list.  In most cases, it is not necessary to close\r\n\tthe stream explicitly at all, because it will be closed automatically\r\n\ton garbage collection or on failure.\r\n\t</P><P>\r\n\tNOTE about cuts in current ECLiPSe versions: If a unification is\r\n\tfollowed immediately by a cut, and the unification causes waking,\r\n\tthe waking occurs only after the cut.  A unification that creates\r\n\tan element of the lazy list may therefore need a dummy 'true' goal\r\n\tbefore a subsequent cut in order to force waking.\r\n    </P>"), eg : "\r\n    copy_file(Old, New) :-\r\n\topen(Old, read, In),\r\n\topen(New, write, Out),\r\n\tstream_to_lazy_list(In, Codes),\r\n\t( foreach(C,Codes), param(Out) do put(Out, C) ),\r\n\tclose(In),\r\n\tclose(Out).\r\n    "]).
