:- module(gfd).
:- export op(700, xfx, [#::]).
:- export op(750, fx, [neg]).
:- export op(760, yfx, [and]).
:- export op(770, yfx, [or, xor]).
:- export op(790, yfx, [<=>]).
:- export op(780, yfx, [=>]).
:- export #:: / 2.
:- export (::) / 2.
:- export #:: / 3.
:- export (::) / 3.
:- export (#\=) / 2.
:- export (#=) / 2.
:- export (#<) / 2.
:- export (#>) / 2.
:- export (#>=) / 2.
:- export (#=<) / 2.
:- export (#\=) / 3.
:- export (#=) / 3.
:- export (#<) / 3.
:- export (#>) / 3.
:- export (#>=) / 3.
:- export (#=<) / 3.
:- export sumlist / 2.
:- export sum / 2.
:- export sum / 3.
:- export sum / 4.
:- export min / 2.
:- export max / 2.
:- export scalar_product / 4.
:- export scalar_product / 5.
:- export divmod / 4.
:- export all_le / 2.
:- export all_lt / 2.
:- export all_ge / 2.
:- export all_gt / 2.
:- export all_eq / 2.
:- export all_ne / 2.
:- export bool_channeling / 3.
:- export inverse / 2.
:- export inverse / 4.
:- export inverse_g / 2.
:- export inverse_g / 4.
:- export ordered / 2.
:- export lex_le / 2.
:- export lex_lt / 2.
:- export lex_ge / 2.
:- export lex_gt / 2.
:- export lex_eq / 2.
:- export lex_ne / 2.
:- export mem / 2.
:- export mem / 3.
:- export alldifferent / 1.
:- export alldifferent_cst / 2.
:- export nvalues / 3.
:- export gcc / 2.
:- export occurrences / 3.
:- export atmost / 3.
:- export atleast / 3.
:- export count / 4.
:- export count_matches / 4.
:- export among / 4.
:- export element / 3.
:- export element_g / 3.
:- export precede / 2.
:- export precede / 3.
:- export sorted / 2.
:- export sorted / 3.
:- export sorted_g / 3.
:- export circuit / 1.
:- export circuit / 3.
:- export circuit / 4.
:- export circuit_offset / 2.
:- export circuit_offset / 4.
:- export circuit_offset / 5.
:- export circuit_g / 1.
:- export circuit_g / 3.
:- export circuit_g / 4.
:- export circuit_offset_g / 2.
:- export circuit_offset_g / 4.
:- export circuit_offset_g / 5.
:- export ham_path / 3.
:- export ham_path / 5.
:- export ham_path / 6.
:- export ham_path_offset / 4.
:- export ham_path_offset / 6.
:- export ham_path_offset / 7.
:- export ham_path_g / 3.
:- export ham_path_g / 5.
:- export ham_path_g / 6.
:- export ham_path_offset_g / 4.
:- export ham_path_offset_g / 6.
:- export ham_path_offset_g / 7.
:- export disjunctive / 2.
:- export disjunctive_optional / 3.
:- export disjoint2 / 1.
:- export disjoint2_optional / 1.
:- export cumulative / 4.
:- export cumulative_optional / 5.
:- export cumulatives / 5.
:- export cumulatives_min / 5.
:- export cumulatives_g / 5.
:- export cumulatives_min_g / 5.
:- export sequence / 5.
:- export sequence / 4.
:- export bin_packing / 3.
:- export bin_packing_g / 3.
:- export bin_packing / 4.
:- export table / 2.
:- export table / 3.
:- export extensional / 4.
:- export regular / 2.
:- export labeling / 1.
:- export indomain / 1.
:- export select_var / 5.
:- export try_value / 2.
:- export is_in_domain / 2.
:- export is_in_domain / 3.
:- export search / 6.
:- export gfd_update / 0.
:- export and / 2.
:- export or / 2.
:- export xor / 2.
:- export <=> / 2.
:- export => / 2.
:- export neg / 1.
:- export and / 3.
:- export or / 3.
:- export xor / 3.
:- export <=> / 3.
:- export => / 3.
:- export neg / 2.
:- export get_min / 2.
:- export get_max / 2.
:- export get_median / 2.
:- export get_bounds / 3.
:- export get_integer_bounds / 3.
:- export get_finite_integer_bounds / 3.
:- export get_domain / 2.
:- export get_domain_as_list / 2.
:- export get_domain_size / 2.
:- export get_delta / 2.
:- export get_constraints_number / 2.
:- export get_weighted_degree / 2.
:- export get_regret_lwb / 2.
:- export get_regret_upb / 2.
:- export impose_min / 2.
:- export impose_max / 2.
:- export impose_bounds / 3.
:- export impose_domain / 2.
:- export exclude / 2.
:- export exclude_range / 3.
:- export gfd_vars_impose_min / 2.
:- export gfd_vars_impose_max / 2.
:- export gfd_vars_impose_bounds / 3.
:- export gfd_vars_impose_domain / 2.
:- export gfd_vars_exclude / 2.
:- export gfd_vars_exclude_range / 3.
:- export gfd_vars_exclude_domain / 2.
:- export is_solver_type / 1.
:- export is_solver_var / 1.
:- export is_exact_solver_var / 1.
:- export integers / 1.
:- export msg / 3.
:- export gfd_maxint / 1.
:- export gfd_minint / 1.
:- export gfd_get_default / 2.
:- export gfd_set_default / 2.
:- tool((#\=) / 2, '#\\=_body' / 3).
:- tool((#=) / 2, '#=_body' / 3).
:- tool((#<) / 2, '#<_body' / 3).
:- tool((#>) / 2, '#>_body' / 3).
:- tool((#>=) / 2, '#>=_body' / 3).
:- tool((#=<) / 2, '#=<_body' / 3).
:- tool((#\=) / 3, '#\\=_reif_body' / 4).
:- tool((#=) / 3, '#=_reif_body' / 4).
:- tool((#<) / 3, '#<_reif_body' / 4).
:- tool((#>) / 3, '#>_reif_body' / 4).
:- tool((#>=) / 3, '#>=_reif_body' / 4).
:- tool((#=<) / 3, '#=<_reif_body' / 4).
:- tool('#\\=_c' / 3, '#\\=_c' / 4).
:- tool('#=_c' / 3, '#=_c' / 4).
:- tool('#<_c' / 3, '#<_c' / 4).
:- tool('#>_c' / 3, '#>_c' / 4).
:- tool('#>=_c' / 3, '#>=_c' / 4).
:- tool('#=<_c' / 3, '#=<_c' / 4).
:- tool('#\\=_reif_c' / 4, '#\\=_reif_c' / 5).
:- tool('#=_reif_c' / 4, '#=_reif_c' / 5).
:- tool('#<_reif_c' / 4, '#<_reif_c' / 5).
:- tool('#>_reif_c' / 4, '#>_reif_c' / 5).
:- tool('#>=_reif_c' / 4, '#>=_reif_c' / 5).
:- tool('#=<_reif_c' / 4, '#=<_reif_c' / 5).
:- tool((::) / 2, '::_body' / 3).
:- tool(#:: / 2, '::_body' / 3).
:- export gfd_var_print / 2.
:- export gfd_copy_var / 2.
:- export struct(gfd_prob(cp_stamp, nvars, nevents, vars, prop, last_anc, space, events, events_tail)).
:- export portray(gfd_prob / 9, gfd_handle_tr_out / 2, []).
:- export gfd_handle_tr_out / 2.
:- export struct(gfd_space(handle, stamp)).
:- export struct(gfd(idx, bool, prob, any, set)).
:- tool(and / 2, and_body / 3).
:- tool(or / 2, or_body / 3).
:- tool(xor / 2, xor_body / 3).
:- tool(neg / 1, neg_body / 2).
:- tool(<=> / 2, '<=>_body' / 3).
:- tool(=> / 2, '=>_body' / 3).
:- tool(and / 3, and_reif_body / 4).
:- tool(or / 3, or_reif_body / 4).
:- tool(xor / 3, xor_reif_body / 4).
:- tool(neg / 2, neg_reif_body / 3).
:- tool(<=> / 3, '<=>_reif_body' / 4).
:- tool(=> / 3, '=>_reif_body' / 4).
:- tool(and_c / 3, and_c / 4).
:- tool(or_c / 3, or_c / 4).
:- tool(xor_c / 3, xor_c / 4).
:- tool(neg_c / 2, neg_c / 3).
:- tool('<=>_c' / 3, '<=>_c' / 4).
:- tool('=>_c' / 3, '=>_c' / 4).
:- tool(and_reif_c / 4, and_reif_c / 5).
:- tool(or_reif_c / 4, or_reif_c / 5).
:- tool(xor_reif_c / 4, xor_reif_c / 5).
:- tool(neg_reif_c / 3, neg_reif_c / 4).
:- tool('<=>_reif_c' / 4, '<=>_reif_c' / 5).
:- tool('=>_reif_c' / 4, '=>_reif_c' / 5).
:- tool(among / 4, among_body / 5).
:- tool(among_c / 5, among_c / 6).
:- tool((::) / 3, '::_body' / 4).
:- tool(#:: / 3, '::_body' / 4).
:- export struct(gcc(low, high, value)).
:- export struct(occ(occ, value)).
:- export struct(rect(x, y, w, h, b)).
:- export struct(trans(f, l, t)).
:- export max_regret_lwb / 2.
:- export max_regret_upb / 2.
:- export max_weighted_degree / 2.
:- export most_constrained_per_value / 2.
:- export max_weighted_degree_per_value / 2.
:- export struct(gfd_stats(prop, fail, nodes, depth, mem)).
:- export struct(gfd_control(commit_distance, adaptive_distance, threads)).
:- tool(gfd_vars_impose_domain / 2, gfd_vars_impose_domain / 3).
:- tool(gfd_vars_exclude_domain / 2, gfd_vars_exclude_domain / 3).
:- comment(include, "gfd_comments.ecl").
:- comment(categories, ["Constraints"]).
:- comment(summary, "Interface to gecode solver for integer finite domains").
:- comment(author, "Kish Shen").
:- comment(desc, html("<P>\n   The GFD library is an interface to the gecode finite domain constraint\n   solver. Gecode (www.gecode.org) is an open-source toolkit for developing\n   constraint-based systems in C++, and includes a high-performance constraint \n   solver.</P><P>\n\n   This interface provides a high degree of compatibility with the finite \n   domain portion of the IC library, and to a lesser extent, with the FD\n   library as well. This means that programs originally written for the\n   IC library should run with GFD with little modifications, beyond \n   renaming any explicit calls to the ic family of modules.</P><P>\n\n   The main differences from the IC library are:\n<UL>\n       <LI>Real interval arithmetic and variables are not supported.\n\n       <LI>Domain variables have finite bounds, and the maximum bounds are\n       determined by gecode. Like FD, default finite bounds are given to \n       domain variables that are not explicitly given bounds.\n\n       <LI>Constraint propagation is performed in gecode, and each propagation\n       phase is atomic at the ECLiPSe level. Posting of constraints and \n       propagation of their consequences are separate in gecode. GFD uses a\n       demon suspended goal to perform the propagation: after the posting\n       of any constraint (and other changes to the problem that needs \n       propagation), the suspended goal is scheduled and woken. When the\n       woken goal is executed, propagation is performed. The goal is suspended\n       at priority 9, so if the posting of the constraint is executed at\n       normal priority (12), the propagation will happen immediately. However,\n       if the posting is done at a priority 10 or higher, then the propagation\n       is delayed, allowing multiple constraints to be posted without\n       propagation. \n\n       <LI>GFD supports constraints that are supported by Gecode,\n       so the exact set of constraints supported is different from IC. \n       However, the same basic arithmetic operators and relations are \n       supported, allowing for very similar arithmetic expressions. Also,\n       many, if not most, of the constraints in IC are supported, along with\n       many constraints not supported by IC. See the detailed documentation\n       for more information.\n\n       <LI>All constraints can be called from the gfd module, and in\n       addition, some constraints can be called from modules that specify\n       the consistency level: gfd_gac (generalised arc consistency, aka\n       domain consistency), gfd_bc (bounds consistency), gfd_vc (value\n       consistency (naive)). The calls to gfd uses the default consistency \n       defined for the constraint by gecode. These consistency levels maps \n       directly to those defined for the constraints, so if gecode supports \n       different consistency levels for a constraint, GFD supports it as \n       well. In  particular (and unlike IC), most arithmetic operations can \n       be bounds (the default) as well as domain consistent.\n\n       <LI>gfd:search/6 interfaces to gecode's search-engines, where the\n       entire search is performed in gecode, and the whole search appears\n       atomic at the ECLiPSe level. The syntax for search/6 is designed to\n       be as compatible with IC's search/6, although there are some \n       differences. The exact equivalent to IC's search/6, where the search\n       is performed at the ECLiPSe level, is available via the gfd_search\n       module (in fact it shares the same code with IC's search/6). This\n       provides more flexibility, but is likely to be less efficient,\n       because the search is done in ECLiPSe, and also because \n       it is not optimised for use with gecode. In addition,\n       gfd also provide predicates for both variable selection and\n       value choice that are optimised for gecode, which should be more\n       efficient than those provided by gfd_search.\n\n       <LI>The suspension lists supported by GFD are different from IC.\n       Currently, only the 'any' suspension list (for any changes to the\n       variable's domain) found in FD but not IC, is supported. Not that\n       the GFD constraints are implemented in gecode directly, and therefore\n       do not use GFD's suspension lists. \n\n</UL><P>\n      <P>\n   The following can be used inside arithmetic constraint expressions:\n   <DL>\n   <DT><STRONG>X</STRONG><DD>\n\t    Variables.  If X is not yet a domain variable, it is turned \n\t    into one.\n\n   <DT><STRONG>123</STRONG><DD>\n\t    Integer constants.\n\n   <DT><STRONG>+Expr</STRONG><DD>\n\t    Identity.\n\n   <DT><STRONG>-Expr</STRONG><DD>\n\t    Sign change.\n\n   <DT><STRONG>abs(Expr)</STRONG><DD>\n\t    The absolute value of Expr.\n\n   <DT><STRONG>E1+E2</STRONG><DD>\n\t    Addition.\n\n   <DT><STRONG>E1-E2</STRONG><DD>\n\t    Subtraction.\n\n   <DT><STRONG>E1*E2</STRONG><DD>\n\t    Multiplication.\n\n   <DT><STRONG>E1//E2</STRONG><DD>\n\t    Integer division. Truncate towards zero.\n\n   <DT><STRONG>E1/E2</STRONG><DD>\n\t    Division, defined only where E2 evenly divides E1,\n\n   <DT><STRONG>E1 rem E2</STRONG><DD>\n\t    Integer remainder (modulus), same sign as E1.\n\n   <DT><STRONG>Expr^2</STRONG><DD>\n\t    Square. Equivalent to sqr(Expr).\n\n   <DT><STRONG>min(E1,E2)</STRONG><DD>\n\t    Minimum.\n\n   <DT><STRONG>max(E1,E2)</STRONG><DD>\n\t    Maximum.\n\n   <DT><STRONG>sqr(Expr)</STRONG><DD>\n\t    Square.  Logically equivalent to Expr*Expr.\n\n   <DT><STRONG>isqrt(Expr)</STRONG><DD>\n\t    Integer square root. Truncated to nearest smaller integer.\n\n   <DT><STRONG>sqrt(Expr)</STRONG><DD>\n\t    Square root, defined only where Expr is the square of an integer.\n\n   <DT><STRONG>sum(ExprCol)</STRONG><DD>\n\t    Sum of a collection of expressions.\n\n   <DT><STRONG>sum(IntCol*ExprCol)</STRONG><DD>\n\t    Scalar product of a collection of integers and expressions.\n            IntCol and ExprCol must be the same size.\n\n   <DT><STRONG>min(ExprCol)</STRONG><DD>\n\t    Minimum of a collection of expressions.\n\n   <DT><STRONG>max(ExprCol)</STRONG><DD>\n\t    Maximum of a collection of expressions.\n\n   <DT><STRONG>Functional/reified constraints</STRONG><DD>\n            Written without last argument, which is taken as the value of\n            the expression. Only reified constraints (whose last argument\n            is the 0/1 boolean) and constraints that can be written as \n            functions (last argument is a domain variable) are allowed.\n\n   <DT><STRONG>and</STRONG><DD>\n\t    Reified constraint conjunction.  e.g. X&gt;3 and Y&lt;8\n\n   <DT><STRONG>or</STRONG><DD>\n\t    Reified constraint disjunction.  e.g. X&gt;3 or Y&lt;8\n            These are restricted to the top-level of an expression,\n            and for reifiable expressions only,\n\n   <DT><STRONG>xor</STRONG><DD>\n\t    Reified constraint exclusive disjunction.  e.g. X&gt;3 xor Y&lt;8\n            These are restricted to the top-level of an expression,\n            and for reifiable expressions only,\n\n   <DT><STRONG>=&gt;</STRONG><DD>\n\t    Reified constraint implication.  e.g. X&gt;3 =&gt; Y&lt;8\n            These are restricted to the top-level of an expression,\n            and for reifiable expressions only,\n\n   <DT><STRONG>&lt;=&gt;</STRONG><DD>\n\t    Reified constraint equivalence.  e.g. X&gt;3 &lt;=&gt; Y&lt;8\n            These are restricted to the top-level of an expression,\n            and for reifiable expressions only,\n\n   <DT><STRONG>&gt;=</STRONG><DD>\n\t    Reified constraint reverse implication.  e.g. X&gt;3 &gt;= Y&lt;8\n            These are restricted to the top-level of an expression,\n            and for reifiable expressions only,\n\n   <DT><STRONG>neg</STRONG><DD>\n\t    Reified constraint negation.  e.g. neg X&gt;3\n            These are restricted to the top-level of an expression,\n            and for reifiable expressions only,\n\n   <DT><STRONG>eval(Expr)</STRONG><DD>\n\t    Equivalent to Expr - Expr evaluated at run-time only.\n   </DL>\n")).
:- comment(struct(gfd_stats), [summary : "Structure for obtaining statistics or providing stopping limits for gecode search-engines", desc : "  This structure is used in search/6 predicate, which interface to gecode's\n  search-engines. The structure can be used to obtain statistics of the\n  search via the stats option, in this case the fields of the structure \n  should be uninstantiated, and search/6 will instantiate it when a solution\n  is returned. Secondly, the struct can be used in the limits option, to\n  specify limits for the search, such that the search will be terminated when \n  the specified limit is exceeded. In this case, the fields for which limits \n  are required should be set. Note that not all fields can be used as limits.\n  If the field cannot be used as a limit, it will be ignored.", fields : ["prop" : "Number of propagations performed. (stats only)", "fail" : "Number of failed nodes.", "nodes" : "Number of nodes expanded.", "depth" : "Maximum depth of search stack. (stats only)", "mem" : "peak memory usage (in bytes) by gecode."]]).
:- comment(struct(gfd_control), [summary : "Structure for passing low-level control parameters to gecode search-engines.", desc : "  This structure is used in search/6 predicate, which interface to gecode's\n  search-engines. The structure is used by the control option to pass values\n  for low-level parameters that control the behaviour gecode search-engine.\n  See the gecode documentation for more details explanation of the\n  parameters. For threads, if >= 1, this specifies number of threads\n  to use in search, but for < 1, this specify the number of threads in\n  relation to the number of processors on the machine, see the gecode\n  documentation for more detail. ", fields : ["commit_distance" : "the commit recomputation distance (integer)(member c_d of Gecode::Search::Options)", "adaptive_distance" : "the adaptive recomputation distance (integer)(member a_d of Gecode::Search::Options)", "threads" : "number of threads to use in search (integer or float)(member threads of Gecode::Search::Options)"]]).
:- comment(struct(gcc), [summary : "Bounds specification for gcc constraint.", desc : html("    This structure is used to specify the cardinality (number of occurrences)\n    of one value for the gcc constraint."), fields : ["low" : "Lower bound on the cardinality of Value (integer).", "high" : "Upper bound on the cardinality of Value (integer).", "value" : "Value whose cardinality is being specified."]]).
:- comment(struct(occ), [summary : "Bounds specification for gcc constraint.", desc : html("    This structure is used to specify the cardinality (number of occurrences)\n    of one value for the gcc constraint."), fields : ["occ" : "Domain variable or integer specifying the cardinality of Value.", "value" : "Value whose cardinality is being specified."]]).
:- comment(struct(rect), [summary : "Specification for rectangles used in disjoint2 and disjoint2_optional constraints.", desc : "This structure is used for specify the rectangles used\n in disjoint2 and disjoint2_optional constraints. These rectangles are\n placed on a grid.", fields : ["x" : "the x co-ordinate of the left-side of the rectangle", "y" : "the y co-ordinate of the bottom-side of the rectangle", "w" : "the width of the rectangle", "h" : "the height of the rectangle", "b" : "boolean specifying if rectangle is placed (1=placed)"]]).
:- comment(#:: / 2, [amode : #::(?, ++), template : "?Vars #:: ++Domain", args : ["Vars" : "Variable or collection (a la collection_to_list/2) of variables", "Domain" : "Domain specification"], summary : "Constrain Vars to have the domain Domain.", see_also : [(::) / 2], kind : [constraint], desc : html("<P>\n   Alias of ::/2. See ::/2 for more details.\n</P>\n")]).
:- comment(#:: / 3, [amode : #::(?, ++, ?), template : "#::(?Var, ++Domain, ?Bool)", args : ["Var" : "Variable", "Domain" : "Domain specification", "Bool" : "Reified truth value"], summary : "Reflect into Bool the truth of Var having the domain Domain.", see_also : [_6427 : #:: / 3, #:: / 2], kind : [constraint], desc : html("<P>\n  An alias for ::/3. See ::/3 for more details.</P>\n</P>\n")]).
:- comment((#<) / 2, [amode : (? #< ?), template : "<ConsistencyModule:> ?ExprX #< ?ExprY", args : ["ExprX" : "Integer arithmetic expression", "ExprY" : "Integer arithmetic expression"], summary : "ExprX is less than ExprY.", see_also : [(#=<) / 2, (#=) / 2, (#>=) / 2, (#>) / 2, (#\=) / 2, (#<) / 3, _8933 : (#<) / 2], kind : [constraint : [extra : [gccat : lt]]], desc : html("<P>\n   Constrains ExprX to be less than ExprY.  Also constrains all variables\n   appearing in ExprX and ExprY to be domain variables and checks that all \n   constants and ground sub-expressions are integers.</P><P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: gfd_bc\n   for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. Note that some operators (integer division, modulus)\n   only support bounds consistency and will be propagated with bounds\n   consistency even when posted with gfd_gac.\n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P><P>\n   A more restricted version of this constraint is defined in the \n   global constraint catalog as 'lt'. Here the constraint is defined\n   between two domain variables rather than two expressions.\n</P>\n")]).
:- comment((#<) / 3, [amode : #<(?, ?, ?), template : "<ConsistencyModule:> #<(?ExprX, ?ExprY, ?Bool)", args : ["ExprX" : "Integer arithmetic expression", "ExprY" : "Integer arithmetic expression", "Bool" : "Reified truth value of the constraint"], summary : "Reified ExprX is less than ExprY.", see_also : [(#=<) / 3, (#=) / 3, (#>=) / 3, (#>) / 3, (#\=) / 3, (<) / 3, (#<) / 2, _9214 : (#<) / 3], kind : [constraint], desc : html("<P>\n   This predicate is a reified constraint: it succeeds if and only if the\n   truth value of its associated constraint (the constraint with arity one\n   less and the same arguments except for B) is equal to B, where the value\n   0 means false and 1 true.  This constraint can be used both to test the\n   validity of the associated constraint (entailment test) and to impose\n   this constraint or its negation.  For the former, B will be instantiated\n   as soon as either the associated constraint or its negation is subsumed\n   by the current state of its domain variables.  For the latter, when B is\n   instantiated, then depending on its value, either the associated\n   constraint or its negation will be imposed on its arguments.</P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: gfd_bc\n   for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. Note that some operators (integer division, modulus)\n   only support bounds consistency and will be propagated with bounds\n   consistency even when posted with gfd_gac.\n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P>\n")]).
:- comment((#=) / 2, [amode : (? #= ?), template : "<ConsistencyModule:> ?ExprX #= ?ExprY", args : ["ExprX" : "Integer arithmetic expression", "ExprY" : "Integer arithmetic expression"], summary : "ExprX is equal to ExprY.", see_also : [(#<) / 2, (#=<) / 2, (#>=) / 2, (#>) / 2, (#\=) / 2, (#=) / 3, _6541 : (#=) / 2], kind : [constraint : [extra : [gccat : eq]]], eg : "\n[eclipse 28]: A :: [1,3,5,7], A #= B.\n\nA = A{[1, 3, 5, 7]}\nB = B{[1 .. 7]}\n\n[eclipse 29]: A :: [1,3,5,7], gfd_gac: (A #= B).\n\nA = A{[1, 3, 5, 7]}\nB = B{[1, 3, 5, 7]}\n\n[eclipse 30]:  A :: [1,3,5,7], gfd_gac: ( A #= B + 1).\n\nA = A{[1, 3, 5, 7]}\nB = B{[0, 2, 4, 6]}\n\n\n", desc : html("<P>\n   Constrains ExprX and ExprY to be equal.  Also constrains all variables\n   appearing in ExprX and ExprY to be domain variables and checks that all \n   constants and ground sub-expressions are integers.</P><P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: gfd_bc\n   for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. Note that some operators (integer division, modulus)\n   only support bounds consistency and will be propagated with bounds\n   consistency even when posted with gfd_gac.\n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P><P>\n   A more restricted version of this constraint is defined in the \n   global constraint catalog as 'eq'. Here the constraint is defined\n   between two domain variables rather than two expressions.\n</P>\n")]).
:- comment((#=) / 3, [amode : #=(?, ?, ?), template : "<ConsistencyModule:> #=(?ExprX, ?ExprY, ?Bool)", args : ["ExprX" : "Integer arithmetic expression", "ExprY" : "Integer arithmetic expression", "Bool" : "Reified truth value of the constraint"], summary : "Reified ExprX is equal to ExprY.", see_also : [(#<) / 3, (#=<) / 3, (#>=) / 3, (#>) / 3, (#\=) / 3, (#=) / 2, _6862 : (#=) / 3], kind : [constraint], desc : html("<P>\n   This predicate is a reified constraint: it succeeds if and only if the\n   truth value of its associated constraint (the constraint with arity one\n   less and the same arguments except for B) is equal to B, where the value\n   0 means false and 1 true.  This constraint can be used both to test the\n   validity of the associated constraint (entailment test) and to impose\n   this constraint or its negation.  For the former, B will be instantiated\n   as soon as either the associated constraint or its negation is subsumed\n   by the current state of its domain variables.  For the latter, when B is\n   instantiated, then depending on its value, either the associated\n   constraint or its negation will be imposed on its arguments.</P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: gfd_bc\n   for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. Note that some operators (integer division, modulus)\n   only support bounds consistency and will be propagated with bounds\n   consistency even when posted with gfd_gac.\n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P>\n")]).
:- comment((#=<) / 2, [amode : (? #=< ?), template : "<ConsistencyModule:> ?ExprX #=< ?ExprY", args : ["ExprX" : "Integer arithmetic expression", "ExprY" : "Integer arithmetic expression"], summary : "ExprX is less than or equal to ExprY.", see_also : [(#<) / 2, (#=) / 2, (#>=) / 2, (#>) / 2, (#\=) / 2, (#=<) / 3, _7763 : (#=<) / 2], kind : [constraint : [extra : [gccat : leq]]], desc : html("<P>\n   Constrains ExprX to be less than or equal to ExprY.  Also constrains all\n   variables appearing in ExprX and ExprY to be integral and checks that all\n   constants are integers.</P><P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: gfd_bc\n   for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. Note that some operators (integer division, modulus)\n   only support bounds consistency and will be propagated with bounds\n   consistency even when posted with gfd_gac.\n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P><P>\n   A more restricted version of this constraint is defined in the \n   global constraint catalog as 'leq'. Here the constraint is defined\n   between two domain variables rather than two expressions.\n</P>\n")]).
:- comment((#=<) / 3, [amode : #=<(?, ?, ?), template : "<ConsistencyModule:> #=<(?ExprX, ?ExprY, ?Bool)", args : ["ExprX" : "Integer arithmetic expression", "ExprY" : "Integer arithmetic expression", "Bool" : "Reified truth value of the constraint"], summary : "Reified ExprX is less than or equal to ExprY.", see_also : [(#<) / 3, (#=) / 3, (#>=) / 3, (#>) / 3, (#\=) / 3, (#=<) / 2, _8042 : (#=<) / 3], kind : [constraint], desc : html("<P>\n   This predicate is a reified constraint: it succeeds if and only if the\n   truth value of its associated constraint (the constraint with arity one\n   less and the same arguments except for B) is equal to B, where the value\n   0 means false and 1 true.  This constraint can be used both to test the\n   validity of the associated constraint (entailment test) and to impose\n   this constraint or its negation.  For the former, B will be instantiated\n   as soon as either the associated constraint or its negation is subsumed\n   by the current state of its domain variables.  For the latter, when B is\n   instantiated, then depending on its value, either the associated\n   constraint or its negation will be imposed on its arguments.</P><P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: gfd_bc\n   for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. Note that some operators (integer division, modulus)\n   only support bounds consistency and will be propagated with bounds\n   consistency even when posted with gfd_gac.\n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P>\n")]).
:- comment((#>) / 2, [amode : (? #> ?), template : "<ConsistencyModule:> ?ExprX #> ?ExprY", args : ["ExprX" : "Integer arithmetic expression", "ExprY" : "Integer arithmetic expression"], summary : "ExprX is strictly greater than ExprY.", see_also : [(#<) / 2, (#=<) / 2, (#=) / 2, (#>=) / 2, (#\=) / 2, (#>) / 3, _8347 : (#>) / 2], kind : [constraint : [extra : [gccat : gt]]], desc : html("<P>\n   Constrains ExprX to be greater than ExprY.  Also constrains all variables\n   appearing in ExprX and ExprY to be domain variables and checks that all \n   constants and ground sub-expressions are integers.</P><P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: gfd_bc\n   for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. Note that some operators (integer division, modulus)\n   only support bounds consistency and will be propagated with bounds\n   consistency even when posted with gfd_gac.\n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P><P>\n   A more restricted version of this constraint is defined in the \n   global constraint catalog as 'gt'. Here the constraint is defined\n   between two domain variables rather than two expressions.\n</P>\n")]).
:- comment((#>) / 3, [amode : #>(?, ?, ?), template : "<ConsistencyModule:> #>(?ExprX, ?ExprY, ?Bool)", args : ["ExprX" : "Integer arithmetic expression", "ExprY" : "Integer arithmetic expression", "Bool" : "Reified truth value of the constraint"], summary : "Reified ExprX is strictly greater than ExprY.", see_also : [(#<) / 3, (#=<) / 3, (#=) / 3, (#>=) / 3, (#\=) / 3, (#>) / 2, _8629 : (#>) / 3], kind : [constraint], desc : html("<P>\n   This predicate is a reified constraint: it succeeds if and only if the\n   truth value of its associated constraint (the constraint with arity one\n   less and the same arguments except for B) is equal to B, where the value\n   0 means false and 1 true.  This constraint can be used both to test the\n   validity of the associated constraint (entailment test) and to impose\n   this constraint or its negation.  For the former, B will be instantiated\n   as soon as either the associated constraint or its negation is subsumed\n   by the current state of its domain variables.  For the latter, when B is\n   instantiated, then depending on its value, either the associated\n   constraint or its negation will be imposed on its arguments.</P><P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: gfd_bc\n   for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. Note that some operators (integer division, modulus)\n   only support bounds consistency and will be propagated with bounds\n   consistency even when posted with gfd_gac.\n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P>\n")]).
:- comment((#>=) / 2, [amode : (? #>= ?), template : "<ConsistencyModule:> ?ExprX #>= ?ExprY", args : ["ExprX" : "Integer arithmetic expression", "ExprY" : "Integer arithmetic expression"], summary : "ExprX is greater than or equal to ExprY.", see_also : [(#<) / 2, (#=<) / 2, (#=) / 2, (#>) / 2, (#\=) / 2, (#>=) / 3, _7168 : (#>=) / 2], kind : [constraint : [extra : [gccat : geq]]], desc : html("<P>\n   Constrains ExprX to be greater than or equal to ExprY.  Also constrains\n   all variables appearing in ExprX and ExprY to be domain variables and \n   checks that all constants and ground sub-expressions are integers.</P><P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: gfd_bc\n   for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. Note that some operators (integer division, modulus)\n   only support bounds consistency and will be propagated with bounds\n   consistency even when posted with gfd_gac.\n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P><P>\n   A more restricted version of this constraint is defined in the \n   global constraint catalog as 'geq'. Here the constraint is defined\n   between two domain variables rather than two expressions.\n</P>\n")]).
:- comment((#>=) / 3, [amode : #>=(?, ?, ?), template : "<ConsistencyModule:> #>=(?ExprX, ?ExprY, ?Bool)", args : ["ExprX" : "Integer arithmetic expression", "ExprY" : "Integer arithmetic expression", "Bool" : "Reified truth value of the constraint"], summary : "Reified ExprX is greater than or equal to ExprY.", see_also : [(#<) / 3, (#=<) / 3, (#=) / 3, (#>) / 3, (#\=) / 3, (>=) / 3, (#>=) / 2, _7453 : (#>=) / 3], kind : [constraint], desc : html("<P>\n   This predicate is a reified constraint: it succeeds if and only if the\n   truth value of its associated constraint (the constraint with arity one\n   less and the same arguments except for B) is equal to B, where the value\n   0 means false and 1 true.  This constraint can be used both to test the\n   validity of the associated constraint (entailment test) and to impose\n   this constraint or its negation.  For the former, B will be instantiated\n   as soon as either the associated constraint or its negation is subsumed\n   by the current state of its domain variables.  For the latter, when B is\n   instantiated, then depending on its value, either the associated\n   constraint or its negation will be imposed on its arguments.</P><P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: gfd_bc\n   for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. Note that some operators (integer division, modulus)\n   only support bounds consistency and will be propagated with bounds\n   consistency even when posted with gfd_gac.\n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P>\n")]).
:- comment((#\=) / 2, [amode : (? #\= ?), template : "<ConsistencyModule:> ?ExprX #\\= ?ExprY", args : ["ExprX" : "Integer arithmetic expression", "ExprY" : "Integer arithmetic expression"], summary : "ExprX is not equal to ExprY.", see_also : [(#<) / 2, (#=<) / 2, (#=) / 2, (#>=) / 2, (#>) / 2, (#\=) / 3, _9524 : (#\=) / 2], kind : [constraint : [extra : [gccat : neq]]], desc : html("<P>\n   Constrains ExprX to be not equal to ExprY.  Also constrains all variables\n   appearing in ExprX and ExprY to be domain variable and checks that all \n   constants and ground sub-expressions are integers.</P><P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: gfd_bc\n   for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. Note that some operators (integer division, modulus)\n   only support bounds consistency and will be propagated with bounds\n   consistency even when posted with gfd_gac.\n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P><P>\n   A more restricted version of this constraint is defined in the \n   global constraint catalog as 'neq'. Here the constraint is defined\n   between two domain variables rather than two expressions.\n</P>\n")]).
:- comment((#\=) / 3, [amode : #\=(?, ?, ?), template : "<ConsistencyModule:> #\\=(?ExprX, ?ExprY, ?Bool)", args : ["ExprX" : "Integer arithmetic expression", "ExprY" : "Integer arithmetic expression", "Bool" : "Reified truth value of the constraint"], summary : "Reified ExprX is not equal to ExprY.", see_also : [(#<) / 3, (#=<) / 3, (#=) / 3, (#>=) / 3, (#>) / 3, (=\=) / 3, (#\=) / 2, _9913 : (#\=) / 3], kind : [constraint], desc : html("<P>\n   This predicate is a reified constraint: it succeeds if and only if the\n   truth value of its associated constraint (the constraint with arity one\n   less and the same arguments except for B) is equal to B, where the value\n   0 means false and 1 true.  This constraint can be used both to test the\n   validity of the associated constraint (entailment test) and to impose\n   this constraint or its negation.  For the former, B will be instantiated\n   as soon as either the associated constraint or its negation is subsumed\n   by the current state of its domain variables.  For the latter, when B is\n   instantiated, then depending on its value, either the associated\n   constraint or its negation will be imposed on its arguments.</P><P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: gfd_bc\n   for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. Note that some operators (integer division, modulus)\n   only support bounds consistency and will be propagated with bounds\n   consistency even when posted with gfd_gac.\n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P>\n")]).
:- comment((::) / 2, [amode : (? :: ++), template : "?Vars :: ++Domain", args : ["Vars" : "Variable or collection (a la collection_to_list/2) of variables", "Domain" : "Domain specification"], summary : "Constrain Vars to have the domain Domain.", see_also : [integers / 1, _5931 : (::) / 2, (::) / 3, #:: / 2], kind : [constraint], desc : html("<P>\n   Constrains Vars to take only values from the domain specified by Domain.  \n   Vars may be a variable or a collection of variables (as accepted by \n   collection_to_list/2).  Domain can be specified as a simple range Lo .. Hi, \n   or as a list of sub-ranges and/or individual elements. Each element\n   of the specification is an integer, or is a ground expression that evaluates\n   to an integer. All domain elements must be integers within the range allowed \n   by gecode. \n</P>\n"), eg : "[eclipse 2]: X :: 0..1.\n\nX = X{[0, 1]}\n\n[eclipse 2]: X :: -1..5.\n\nX = X{[-1 .. 5]}\n\n[eclipse 2]: X :: 0.0..1.0.\ntype error in X :: 0.0 .. 1.0\nAbort\n\n[eclipse 2]: [X,Y] :: [1..10, -1, 0, 7, 21].\n\nX = X{[-1 .. 10, 21]}\nY = Y{[-1 .. 10, 21]}\n"]).
:- comment((::) / 3, [amode : ::(?, ++, ?), template : "::(?Var, ++Domain, ?Bool)", args : ["Var" : "Variable", "Domain" : "Domain specification", "Bool" : "Reified truth value"], summary : "Reflect into Bool the truth of Var having the domain Domain.", see_also : [_6144 : (::) / 3, (::) / 2], kind : [constraint], desc : html("<P>\n   Provides a reified form of the ::/2 domain assignment predicate.  This\n   reified ::/3 is defined only to work for one variable (unlike ::/2).\n<P>\n   For a single variable, V, the Bool will be instantiated to 0 if the\n   current domain of V does not intersect with Domain.  It will be\n   instantiated to 1 iff the domain of V is wholly contained within Domain.\n   Finally the Boolean will remain a domain variable in the range 0..1, if\n   neither of the above two conditions hold.\n<P>\n   Instantiating Bool to 1, will cause the constraint to behave exactly like\n   ::/2.  Instantiating Bool to 0 will cause Domain to be excluded from the\n   domain of the variable.\n<P>\n   Note that calling the reified form of :: will result in the Variable\n   becoming a domain variable, even if Bool is uninstantiated.\n<P>\n   Further note that, like other reified predicates, :: can be used infix in\n   a GFD  expression, e.g. B #= (X :: [1..10]) is equivalent to\n   ::(X, [1..10], B).\n</P>\n"), eg : "[eclipse 2]: ::(X, [1..10, 12..30], 1).\n\nX = X{[1 .. 10, 12 .. 30]}\n\n\n[eclipse 2]: ::(X, [1..10, 12..30], 0).\n\nX = X{[-1000000 .. 0, 11, 31 .. 1000000]}\n\n[eclipse 2]: ::(X, [1..10, 12..30], B).\n\nX = X{[-1000000 .. 1000000]}\nB = B{[0, 1]}\n\n[eclipse 2]: gfd:( B #= (X :: [1..10, 12..30])).\n\nB = B{[0, 1]}\nX = X{[-1000000 .. 1000000]}\n\n"]).
:- comment(<=> / 2, [amode : <=>(+, +), template : "<ConsistencyModule:> +ConX <=> +ConY", args : ["ConX" : "Constraint", "ConY" : "Constraint"], summary : "Constraint ConX has the equivalent truth value as ConY.", see_also : [<=> / 3, neg / 1, or / 2, xor / 2, and / 2, => / 2, _42197 : (#=) / 2], kind : [constraint], desc : html("<P>\n   Equivalent to BX #= (ConX), BY #= (ConY), BX #= BY</P>\n   <P>\n   The two constraints are reified in such a way that ConX and ConY constrained\n   to the same truth value. ConX and ConY must be constraints that have a \n   corresponding reified form.</P><P>\n\n   This connective is not available in IC because #=/2 can be used instead.\n   It is provided in GFD as it maps directly to gecode's equivalence \n   connective.</P><P> \n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. \n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P>\n")]).
:- comment(<=> / 3, [amode : <=>(+, +, ?), template : "<ConsistencyModule:> <=>(+ConX,+ConY,Bool)", args : ["ConX" : "Constraint", "ConY" : "Constraint", "Bool" : "Reified truth value of the constraint"], summary : "Bool is the reified truth of constraint ConX is equivalent to the truth of ConY.", see_also : [<=> / 2, neg / 2, => / 3, or / 3, xor / 3, and / 3, _43290 : (#\=) / 3], kind : [constraint : [extra : [gccat : equivalent]]], desc : html("<P>\n   Equivalent to BX #= (ConX), BY #= (ConY), Bool #= (BX #= BY)</P>\n   <P>\n   The two constraints are reified in such a way that Bool is true if ConX\n   and ConY have the same truth value.  ConX and ConY must be\n   constraints that have a corresponding reified form.<P></P>\n\n   This reified connective is not available in IC because #=/3 can be \n   used instead. It is provided in GFD as <=> maps to gecode's \n   equivalence connective.</P><P> \n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. \n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P><P>\n   A more restricted version of this constraint is defined in the \n   global constraint catalog as 'equivalent', in that the reified truth value\n   is the logical equivalance of 0/1 variables rather than constraints.\n</P>\n")]).
:- comment(=> / 2, [amode : =>(+, +), template : "<ConsistencyModule:> +ConX => +ConY", args : ["ConX" : "Constraint", "ConY" : "Constraint"], summary : "Constraint ConX  implies ConY.", see_also : [=> / 3, neg / 1, and / 2, or / 2, xor / 2, <=> / 2, _39875 : => / 2], kind : [constraint], desc : html("<P>\n   Equivalent to BX #= (ConX), BY #= (ConY), BX #=&lt; BY</P>\n   <P>\n   The two constraints are reified in such a way that ConX being true\n   implies that ConY must also be true.  ConX and ConY must be constraints\n   that have a corresponding reified form.<P></P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. \n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P>\n")]).
:- comment(=> / 3, [amode : =>(+, +, ?), template : "<ConsistencyModule:> =>(+ConX,+ConY,Bool)", args : ["ConX" : "Constraint", "ConY" : "Constraint", "Bool" : "Reified truth value of the constraint"], summary : "Bool is the reified truth of constraint ConX implying the truth of ConY.", see_also : [=> / 2, neg / 2, or / 3, xor / 3, and / 3, <=> / 3, _40947 : => / 3], kind : [constraint : [extra : [gccat : imply]]], desc : html("<P>\n   Equivalent to BX #= (ConX), BY #= (ConY), Bool #= (BX #=&lt; BY)</P>\n   <P>\n   The two constraints are reified in such a way that Bool is true if ConX\n   being true implies that ConY must also be true.  ConX and ConY must be\n   constraints that have a corresponding reified form.<P></P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. \n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P><P>\n   A more restricted version of this constraint is defined in the \n   global constraint catalog as 'imply', in that the reified truth value\n   is the logical implication of 0/1 variables rather than constraints.\n</P>\n")]).
:- comment(all_eq / 2, [summary : "Constrains Collection to be equal to Y.", template : "<ConsistencyModule:> all_eq(?Collection,?Y)", amode : all_eq(+, ?), args : ["Collection" : "Collection of integers or domain variables", "Y" : "An integer or domain variable"], kind : [constraint : [extra : [gccat : [arith]]]], eg : "[eclipse 51]: all_eq([1,2,3,5], X).     % fail\n\n[eclipse 52]: all_eq([1,1,1,1], X).\n\nX = 1\n\n[eclipse 53]: [X,Y] :: 0..10, Z :: 9..15, all_eq([X,Y,Z], A).\n\nX = X{[9, 10]}\nY = Y{[9, 10]}\nZ = Z{[9, 10]}\nA = A{[9, 10]}\n\n", desc : html("   Constrains every element in Collection to be equal to Y.\n   </P><P> \n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised \n   arc) consistency. \n</P><P>\n   This constraint is known as arith (with the equal to relation)\n   in the Global Constraint Catalog, and is implemented using\n   Gecode's rel() constraint.\n"), see_also : [(#=<) / 2, all_le / 2, all_gt / 2, all_ge / 2, all_lt / 2, all_ne / 2]]).
:- comment(all_ge / 2, [summary : "Constrains Collection to be greater than or equal to Y.", template : "<ConsistencyModule:> all_ge(?Collection,?Y)", args : ["Collection" : "Collection of integers or domain variables", "Y" : "An integer or domain variable"], amode : all_ge(+, ?), kind : [constraint : [extra : [gccat : [arith]]]], eg : "[eclipse 34]: [X,Y,Z] :: 1..10, all_ge([X,Y,Z], 5).\n\nX = X{[5 .. 10]}\nY = Y{[5 .. 10]}\nZ = Z{[5 .. 10]}\n\n[eclipse 35]: [X,Y,Z] :: 1..10, all_ge([X,Y,Z], A).\n\nX = X{[1 .. 10]}\nY = Y{[1 .. 10]}\nZ = Z{[1 .. 10]}\nA = A{[-1000000 .. 10]}\n\n[eclipse 36]: all_ge([3,4,5],3).            % succeed\n\n[eclipse 37]: all_ge([2,3,4,5],3).          % fail\n\n", desc : html("   Constrains every element in Collection to be greater than or equal\n   to Y.\n   </P><P> \n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised \n   arc) consistency. \n</P><P>\n   This constraint is known as arith (with the greater than or equal to \n   relation) in the Global Constraint Catalog, and is implemented using\n   Gecode's rel() constraint.\n"), see_also : [(#>=) / 2, all_lt / 2, all_gt / 2, all_le / 2, all_ne / 2, all_eq / 2]]).
:- comment(all_gt / 2, [summary : "Constrains Collection to be greater than Y.", template : "<ConsistencyModule:> all_gt(?Collection,?Y)", amode : all_gt(+, ?), args : ["Collection" : "Collection of integers or domain variables", "Y" : "An integer or domain variable"], kind : [constraint : [extra : [gccat : [arith]]]], eg : "[eclipse 27]: all_gt([4,5,6,7], 4).      % succeed\n\n[eclipse 28]: all_gt([5,6,7], 4).        % fail\n\n", desc : html("   Constrains every element in Collection to be greater than Y.\n   </P><P> \n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised \n</P><P>\n   This constraint is known as arith (with the greater than relation)\n   in the Global Constraint Catalog, and is implemented using\n   Gecode's rel() constraint.\n"), see_also : [(#<) / 2, all_le / 2, all_lt / 2, all_ge / 2, all_ne / 2, all_eq / 2]]).
:- comment(all_le / 2, [summary : "Constrains all in Collection to be less than or equal to Y.", template : "<ConsistencyModule:> le(?Collection,?Y)", amode : all_le(+, ?), args : ["Collection" : "Collection of integers\n or domain variables", "Y" : "An integer or domain variable"], kind : [constraint : [extra : [gccat : [arith]]]], eg : "[eclipse 2]: all_le([X,Y,Z],3).\n\nX = X{[-1000000 .. 3]}\nY = Y{[-1000000 .. 3]}\nZ = Z{[-1000000 .. 3]}\n\n[eclipse 3]: [X,Y] :: 1..10, Z :: 2..5, A :: [1,3..5], all_le([X,Y,Z], A).\n\n\nX = X{[1 .. 5]}\nY = Y{[1 .. 5]}\nZ = Z{[2 .. 5]}\nA = A{[3 .. 5]}\n\n[eclipse 4]: all_le([2,3,4], 3).   % fail\n\n", desc : html("   Constrain every element in Collection to be less than or equal to  Y.\n   </P><P> \n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised \n   arc) consistency. \n</P><P>\n   The constraint is known as arith (with the less than or equal\n   relation) in the Global Constraint Catalog.This constraint\n   is implemented using Gecode's rel() constraint.\n"), see_also : [(#=<) / 2, all_lt / 2, all_gt / 2, all_ge / 2, all_ne / 2, all_eq / 2]]).
:- comment(all_lt / 2, [summary : "Constrains Collection to be less than Y.", template : "<ConsistencyModule:> lt(?Collection,?Y)", amode : all_lt(+, ?), args : ["Collection" : "Collection of integers or domain variables", "Y" : "An integer or domain variable"], kind : [constraint : [extra : [gccat : [arith]]]], eg : "[eclipse 16]:   all_lt([A,B,C,D], 3).\n\nA = A{[-1000000 .. 2]}\nB = B{[-1000000 .. 2]}\nC = C{[-1000000 .. 2]}\nD = D{[-1000000 .. 2]}\n\n[eclipse 17]: all_lt([0,1,2], 3).     % succeeds\n\n[eclipse 18]: all_lt([0,1,2,3], 3).   % fails\n\n", desc : html("   Constrains every element in Collection to be less than Y.\n   </P><P> \n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised \n   arc) consistency. \n</P><P>\n   This constraint is known as arith (with the less than relation) in \n   the Global Constraint Catalog. This constraint is\n   implemented using Gecode's rel() constraint.\n"), see_also : [(#=<) / 2, all_le / 2, all_gt / 2, all_ge / 2, all_ne / 2, all_eq / 2]]).
:- comment(all_ne / 2, [summary : "Constrains Collection to be not equal to Y.", template : "<ConsistencyModule:> all_ne(?Collection,?Y)", amode : all_ne(+, ?), args : ["Collection" : "Collection of integers or domain variables", "Y" : "An integer or domain variable"], kind : [constraint : [extra : [gccat : [arith]]]], eg : "[eclipse 45]:  X :: 1..10, all_ne([1,3,4,5], X).\n\nX = X{[2, 6 .. 10]}\n\n[eclipse 46]: all_ne([1,3,4,5], 2).       % succeed\n\n[eclipse 47]: all_ne([1,3,4,5], 4).       % fail\n\n", desc : html("   Constrains every element in Collection to be greater than or equal\n   to Y.\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised \n   arc) consistency. \n</P><P>\n   This constraint is known as arith (with the not equal to relation)\n   in the Global Constraint Catalog, and is implemented using\n   Gecode's rel() constraint.\n"), see_also : [(#=<) / 2, all_le / 2, all_gt / 2, all_ge / 2, all_lt / 2, all_eq / 2]]).
:- comment(alldifferent / 1, [amode : alldifferent(+), template : "<ConsistencyModule:> alldifferent(+Vars)", args : ["Vars" : "A collection (a la collection_to_list/2) of variables or integers"], summary : "All elements of Vars are different.", see_also : [alldifferent_cst / 2, _12685 : alldifferent / 1, collection_to_list / 2], kind : [constraint : [extra : [gccat : alldifferent]]], desc : html("<P>\n   Constrains all elements of a collection to be different from each other.\n   Semantically, all elements of the collection are pairwise different.\n</p><p>\n   This constraint is also known as alldifferent_cst in the global constraints \n   catalog, and is implemented using Gecode's distinct() constraint.</P><P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_vc for value consistency (naive), gfd_bc for bounds consistency, \n   and gfd_gac for domain (generalised arc) consistency. \n</P>\n")]).
:- comment(alldifferent_cst / 2, [amode : alldifferent_cst(+, ++), template : "<ConsistencyModule:> alldifferent_cst(+Vars,++Offsets)", args : ["Vars" : "A collection (a la collection_to_list/2) of variables or integers", "Offsets" : "A collection (a la collection_to_list/2) of integers, with the same cardinality as Vars."], summary : "The values of each element plus corresponding offset are pair-wised different.", see_also : [alldifferent / 1, collection_to_list / 2], kind : [constraint : [extra : [gccat : alldifferent_cst]]], desc : html("<P>\n   Constrains all elements of Vars plus its corresponding offset value in\n   Offset to be different. That is, \n<PRE>\n        Vari + Offseti #\\= Varj + Offsetj, i #\\= j\n</PRE>\n   where Vari, Offseti are the i'th element of Vars and Offsets, and\n   Varj, Offsetj are the j'th element.</P><P>\n\n   This constraint is also known as alldifferent_cst in the global constraints \n   catalog, and is implemented using Gecode's distinct() constraint.</P><P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_vc for value consistency (naive), gfd_bc for bounds consistency, \n   and gfd_gac for domain (generalised arc) consistency.</P><P> \n")]).
:- comment(among / 4, [summary : "The number of occurrence (Occ) in Vars of values taken from the set of values specified in Values satisfy  the relation Occ Rel N", template : "<ConsistencyModule:> among(+Values, ?Vars, +Rel, ?N)", args : ["+Values" : "A collection of specifications for integer values", "?Vars" : "A collection (a la collection_to_list/2) of domain variables or integers", "+Rel" : "One of the atom: #>, #>=, #<, #=<, #=, #\\=", "?N" : "An integer or domain variable"], kind : [constraint : [extra : [gccat : counts]]], eg : "[eclipse 24]: among([1,3,4,9], [4,5,5,4,1,5], (#=), N).\n\nN = 3\n\n\n[eclipse 25]: among([1..4,9],  [4,5,5,4,1,5], (#=), N).\n\nN = 3\n\n\n[eclipse 26]:  among([1..4,3,9], [4,5,5,4,1,5], (#=), N). % repeated value\n\nN = 3\n\n[eclipse 2]: among([], [4,5,5,4,1,5], (#=), N).\n\nN = 0\n\n[eclipse 3]: among([1,2,3], [], (#=), N).\n\nN = 0\n\n[eclipse 5]: among([1,3,4,9], [4,5,5,4,1,5], (#\\=), N).\n\nN = N{[-1000000 .. 2, 4 .. 1000000]}\n\n", desc : html("<P>   Constrain the number of occurrences in Vars of values taken from the set of\n   values specified in Value to satisfy the constraint defined by Rel:\n<PRE>\n          <number of occurrences of values among Values in Vars> Rel N\n</PRE><P>\n   Rel can be one of #&gt;, #&gt;=, #&lt;, #=&lt;, #=, #\\= (or equivalently,\n   &gt;, &gt;=, &lt;, =&lt;, =, \\=).\n</P><P>\n   Values specify the values whose occurrence are counted, and accept\n   the same syntax as domain specification, i.e. each item can be a\n   a simple element, or a range Lo .. Hi. Each element is either an\n   integer, or is a ground expression that evaluates to an integer. \n</P><P>\n   This constraint can be embedded in a constraint expression in its\n   functional form (without the last argument).\n</P><P>\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_gac for domain (generalised arc) consistency. \n</P><P>\n   This constraint is known as counts in the global constraint catalog,\n   with among and among_vars being the specialised form with #= as \n   the Rel (i.e. The number of occurrences of values from Values is\n   exactly N), the name among is used here to better distinguish this\n   constraint from count/4, for counting the occurrences of a single value.\n   This constraint is implemented by gecode's count() constraint (the variant\n   with an IntSet argument for Values).\n</P>\n")]).
:- comment(and / 2, [amode : and(+, +), template : "<ConsistencyModule:> +ConX and +ConY", args : ["ConX" : "Constraint", "ConY" : "Constraint"], summary : "Constraints ConX and ConY must both be true.", see_also : [and / 3, neg / 1, neg / 2, or / 2, xor / 2, => / 2, <=> / 2, _32839 : and / 2], kind : [constraint], desc : html("<P>\n   Equivalent to BX #= (ConX), BY #= (ConY), BX + BY #= 2</P>\n   <P>\n   The two constraints are reified in such a way that both must be true.\n   ConX and ConY must be a constraints that have a corresponding reified\n   form.</P><P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. \n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P>\n")]).
:- comment(and / 3, [amode : and(+, +, ?), template : "<ConsistencyModule:> and(+ConX,+ConY,Bool)", args : ["ConX" : "Constraint", "ConY" : "Constraint", "Bool" : "Reified truth value of the constraint"], summary : "Bool is the reified truth of both constraints ConX and ConY being true.", see_also : [and / 2, neg / 2, or / 3, xor / 3, => / 3, <=> / 3, _33947 : and / 3], kind : [constraint : [extra : [gccat : and]]], desc : html("<P>\n   Equivalent to BX #= (ConX), BY #= (ConY), Bool #= (BX + BY #= 2)</P>\n   <P>\n   The two constraints are reified in such a way that Bool reflects the\n   truth of both being true.  ConX and ConY must be constraints that have a\n   corresponding reified form.<P></P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. \n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P><P>\n   A more restricted version of this constraint is defined in the \n   global constraint catalog as 'and', in that the reified\n   truth value is the logical conjunctions of 0/1 variables rather than \n   constraints.\n</P>\n")]).
:- comment(atleast / 3, [summary : "Atleast N elements of Vars have the value V.", template : "<ConsistencyModule:> atleast(?N, +Vars, +V)", amode : atleast(?, +, +), kind : [constraint : [extra : [gccat : atleast]]], eg : "\n[eclipse 2]: N :: [3,6], atleast(N, [3,A,3,5,3,3], 3).\n\nN = 3\nA = A{[-1000000 .. 1000000]}\n", desc : html("   This constraint ensures that at least N elements of Vars have the value V.\n</p><p>\n   This constraint is a specialisation of the more general count/4\n   constraint, with the (#&gt;=) relation, i.e. the occurrences of V\n   is greater than or equal to N. Note that the order in which N and V\n   occur in the constraint are swapped with respect to occurrences/3\n   and count/4; this is for compatibility with the argument order in\n   IC (for atmost/3).\n<P>\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_gac for domain (generalised arc) consistency. Note that if\n   V is a domain variable, then the propagation is weak, achieving\n   neither domain or bound consistency until V becomes ground.\n </p><p>\n   This constraint is also known as atleast in the global constraint\n   catalog, where N is restricted to an integer; the more general \n   count/4 constraint is also known as count in the global \n   constraint catalog, and the constraint is implemented using \n   Gecode's count() constraint.\n</p><p>\n   The constraint is also known as atleast in the global constraint\n   catalog, and is implemented using Gecode's count() constraint.\n</p>\n"), args : ["N" : "An integer or domain variable", "Vars" : "A collection (a la collection_to_list/2) of domain variables or integers", "V" : "An integer"], fail_if : "   Fails if less than N elements of Vars can be instantiated to V.", see_also : [count / 4, atmost / 3, element / 3, occurrences / 3, collection_to_list / 2]]).
:- comment(atmost / 3, [summary : "At most N elements of Vars have the value V.", template : "<ConsistencyModule:> atmost(?N, +Vars, +V)", amode : atmost(?, +, +), kind : [constraint : [extra : [gccat : atmost]]], eg : "\n[eclipse 33]: atmost(N,  [3, 5, 1, 4, 1, 3], 1).\n\nN = N{[2 .. 6]}\n\n[eclipse 34]: N :: [3,5], atmost(N, [3,A,3,5,3,3], 3).\n\nN = 5\nA = A{[-1000000 .. 1000000]}\n\n[eclipse 35]:  N :: [3,6], atmost(N, [3,A,3,5,3,3], 3).\n\nN = 6\nA = A{[-1000000 .. 1000000]}\n\n[eclipse 36]: N::[1..3], atmost(N, [3,4,2,3,1], 3).\n\nN = N{[2, 3]}\n\n", desc : html("   This constraint ensures that at most N element of Vars have the value V.\n</p><p>\n   This constraint is a specialisation of the more general count/4\n   constraint, with the (#=&lt;) relation, i.e. the occurrences of V\n   is less than or equal to N. Note that the order in which N and V\n   occur in the constraint are swapped with respect to occurrences/3\n   and count/4; this is for compatibility with the argument order in\n   IC.\n<P>\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_gac for domain (generalised arc) consistency. Note that if\n   V is a domain variable, then the propagation is weak, achieving\n   neither domain or bound consistency until V becomes ground.\n </p><p>\n   This constraint is also known as atmost in the global constraint\n   catalog, where N is restricted to an integer; the more general \n   count/4 constraint is also known as count in the global \n   constraint catalog, and the constraint is implemented using \n   Gecode's count() constraint.\n</p><p>\n   The constraint is also known as atmost in the global constraint\n   catalog, and is implemented using Gecode's count() constraint.\n  </p>\n"), args : ["N" : "An integer or domain variable", "+Vars" : "A collection (a la collection_to_list/2) of domain variables or integers", "V" : "An integer"], fail_if : "   Fails if more than N elements of Vars can be instantiated to V.", see_also : [_50151 : atmost / 3, count / 4, atleast / 3, element / 3, occurrences / 3, collection_to_list / 2]]).
:- comment(bin_packing / 3, [amode : bin_packing(+, ++, +), args : ["Items" : "A collection of M variables or integers (domain/value between 1 and N)", "ItemSizes" : "A collection of M non-negative integers", "BinLoads" : "A collection of N variables or non-negative integers"], see_also : [bin_packing / 4, bin_packing_g / 3, _104728 : bin_packing / 3], summary : "The one-dimensional bin packing constraint with loads: packing M items into N bins, each bin having a load", kind : [constraint : [extra : [gccat : bin_packing]]], eg : "\n[eclipse 7]: bin_packing([3,1,3], [4,3,1], [L1,L2,L3,L4]).\n\nL1 = 3\nL2 = 0\nL3 = 5\nL4 = 0\n\n", desc : html("   This constraint is for one-dimensional bin-packing, that is, to pack M\n   items with individual sizes into N bins, such that the sum of sizes of\n   items in each bin equals the load of that bin, as specified in BinLoads.\n   Each element of Items and its corresponding element in ItemSizes\n   represents an item, such that the i'th element of ItemSizes is the size\n   of the i'th item, and the i'th element of Item is the bin this item is\n   packed into. BinLoads represent the load of each bin, i.e. the sum\n   of the sizes of items assigned to that bin, with the j'th element \n   representing the load for bin j. An (integer finite domain) variable for \n   the load allows a constraint on the load to be specified, such as a\n   minimum and/or maximum load for the bin.\n</P><P>\n    Note that the Gecode implementation of this constraint has index starting\n    from 0, i.e. the numbering for the bins starts from 0. These native \n    indices are mapped to the  ECLiPSe indices starting from 1 with an \n    additional dummy zero'th bin that is assigned a dummy item 0. A version\n    of this constraint that uses native Gecode indexing is available \n    as bin_packing_g/3.\n</P><P>\n   The global constraint catalog describes this constraint as a\n   variation of their bin_packing constraint where the fixed capacity for\n   every bin is replaced by the BinLoads variables. In addition, a more\n   restricted version of this constraint is also described in the global \n   constraint catalog as bin_packing_capa, where instead of BinLoads,\n   each bin is given its own integer capacity, the maximum load that\n   bin can take, this is equivalent to giving the corresponding variable \n   for the bin in BinLoads the domain 0..Capacity. \n</p><p>\n   This constraint is implemented using Gecode's binpacking() constraint.\n</p>\n")]).
:- comment(bin_packing / 4, [amode : bin_packing(+, ++, +, +), args : ["Items" : "A collection of M variables or integers (domain/value between 1 and N)", "ItemSizes" : "A collection of M non-negative integers", "N" : "A positive Integer", "BinSize" : "A non-negative integer"], see_also : [bin_packing / 3, cumulative / 4, _106875 : bin_packing / 4], summary : "The one-dimensional bin packing constraint: packing M items into N bins of size BinSize.", eg : "\n[eclipse 4]: bin_packing([3,1,3], [4,3,1], 3, 5).  % Succeed\n\n[eclipse 5]: bin_packing([3,3,3], [4,3,1], 3, 5).  % Fails\n\n", kind : [constraint : [extra : [gccat : bin_packing]]], desc : html("   This constraint is for one-dimensional bin-packing, that is, to pack M\n   items with individual sizes into N bins, such that the sum of sizes of \n   items in each bin does not exceed BinSize. Each element of Items and its \n   corresponding element in ItemSizes represents an item, such that the i'th \n   element of ItemSizes is the size of the i'th item, and the i'th element in\n   Items is the bin this item is packed into. \n</P><P>\n   This constraint can be seen as a special case of the cumulative/4\n   constraint, where all task durations are equal to 1, each bin\n   represents a time point, and BinSize corresponds to the Resource.\n</p><p>\n   This constraint is implemented using the more general \n   bin_packing/3, where each bin has its own size, represented by a domain\n   variable, as this is what is implemented by Gecode. This form of\n   the constraint with a fixed BinSize is more common. so it is\n   provided for convenience and compatibility. Note that this constraint\n   uses ECLiPSe indexing -- bins are indexed starting from 1. There is no     \n   Gecode indexing version of this constraint as it is not implemented\n   directly in Gecode.\n</P><P>\n   This constraint is described in the global constraint catalog as \n   bin_packing, but with slightly different arguments: in the catalog, N\n   (the number of bins) is implicitly defined by the domains of the variables \n   in Items, and the representation of item is grouped into a single argument\n   of collection of pairs, each pair representing an item: the bin to pack \n   the item, and its size. It is implemented using Gecode's binpacking() \n   constraint, with the loads of all bins set to the domain 0..BinSize,i.e..\n   that they all have capacity of BinSize.\n</p>\n")]).
:- comment(bin_packing_g / 3, [amode : bin_packing_g(+, ++, +), args : ["Items" : "A collection of M variables or integers (domain/value between 0 and N-1)", "ItemSizes" : "A collection of M non-negative integers", "BinLoads" : "A collection of N variables or non-negative integers"], see_also : [bin_packing / 4, bin_packing / 3], summary : "The one-dimensional bin packing constraint with loads, using native Gecode indexing", kind : [constraint : [extra : [gccat : bin_packing]]], desc : html("  This version of the constraint uses the native Gecode indexing, which starts \n  from 0. This is different from normal ECLiPSe's indexing, which starts from 1.\n</p><p>\n  This predicate maps more directly to Gecode's native implementation of \n  the constraint, without the conversion between Gecode and ECLiPSe\n  indexing of cumulatives_min/5. It may therefore be more efficient, but \n  could also be incompatible with existing ECLiPSe code. \n</p><p>\n  See bin_packing/3 for a more detailed description of this predicate.")]).
:- comment(bool_channeling / 3, [amode : bool_channeling(?, +, +), template : "<ConsistencyModule:> bool_channeling(?Var, +DomainBools, +Min)", args : ["Var" : "A domain variable", "DomainBools" : "A collection of N 0/1 domain variables or integers", "Min" : "An integer"], summary : "Channel the domain values of Vars to the 0/1 boolean variables in DomainBools", kind : [constraint : [extra : [gccat : domain_constraint]]], see_also : [_59859 : bool_channeling / 3], eg : "\n[eclipse 53]: bool_channeling(V, [0,1,1,0,1,0,0], 3).  % fail\n\n[eclipse 54]:  bool_channeling(V, [0,0,1,0,0,0,B], 3).\n\nV = 5\nB = 0\n\n[eclipse 55]: bool_channeling(V, [B1,B2,B3,B4,B5], 6), B4 = 0.\n\nV = V{[6 .. 8, 10]}\nB1 = B1{[0, 1]}\nB2 = B2{[0, 1]}\nB3 = B3{[0, 1]}\nB4 = 0\nB5 = B5{[0, 1]}\n\n", desc : html("<P>\n    Var is a domain variable whose initial interval is Min..(Min+N),\n    and this constraint links the domain values of Var with the N 0/1\n    variables in DomainBools such that the i'th variable in DomainBools\n    represents the value Min+i, and its value is 0 if the value is not in\n    Var's domain, and 1 if Var is assigned the value [Thus, only one variable\n    in DomainBools can take the value 1].\n</P><P>\n    ConsistencyModule is the optional module specification to give the \n    consistency level for the propagation for this constraint: \n    gfd_gac for generalised arc consistency (domain consistency).\n</P><P>\n    A variant of this constraint, called 'domain_constraint' is in the global \n    constraint catalog. There, instead of having DomainBools and Min, there\n    is a collection of Value-Bool pairs, representing a possible domain value\n    and its associated 0/1 variable. This constraint is implemented using\n    Gecode's channel() constraint (variant with BoolVarArgs and IntVar).\n</P>\n")]).
:- comment(circuit / 1, [amode : circuit(+), args : ["Succ" : "A collection of different variables or integers"], template : "<ConsistencyModule:> circuit(+Succ)", summary : "Constrains elements in Succ to form a Hamiltonian circuit.", see_also : [circuit_g / 1, circuit_offset_g / 2], kind : [constraint : [extra : [gccat : circuit]]], eg : "[eclipse 7]: circuit([2,A,4,1]).\n\nA = 3\n\n[eclipse 2]: circuit([]).\n\nNo (0.00s cpu)\n\n[eclipse 11]: circuit([A]).\n\nA = 1\n\n", desc : html("<P>  Succ is a collection of N elements presenting a digraph of N nodes, where\n  the i'th element of Succ represents the successor to node i. The constraint\n  enforces Succ to form a Hamiltonian circuit, a path through every node in\n  the graph, visiting each node once and forming a circuit.</P><P>\n\n  Note that the Gecode implementation of this constraint has index (node id)\n  starting from 0, rather than 1. This constraint is actually posted\n  as circuit_offset_g/2 with an offset of 1. A version of this constraint\n  with native Gecode indexing is available as circuit_g/1.\n</P><P>\n  ConsistencyModule is the optional module specification to give the \n  consistency level for the propagation for this constraint: \n  gfd_gac for generalised arc consistency (domain consistency), \n  and gfd_vc for value consistency.\n</P><P>\n  This constraint is known as circuit in the global constraint catalog. It is\n  implemented with Gecode's circuit() constraint with an offset of 1.\n</P>\n")]).
:- comment(circuit / 3, [amode : circuit(+, ++, ?), args : ["Succ" : "A collection of N different variables or integers", "CostMatrix" : "A NxN matrix of integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> circuit(+Succ,++CostMatrix,?Cost)", summary : "Constrains elements in Succ to form a Hamiltonian circuit with cost Cost.", see_also : [circuit_offset_g / 4, circuit / 1, circuit / 4, circuit_g / 3], kind : [constraint], eg : "[eclipse 9]: CostM = []([](0,3,5,7),[](4,0,9,6),[](2,1,0,5),[](-7,8,-2,0)),\n             circuit([2,3,4,1], CostM, C).   \n\nCostM = []([](0, 3, 5, 7), [](4, 0, 9, 6), [](2, 1, 0, 5), [](-7, 8, -2, 0))\nC = 10\n", desc : html("<P>  Succ is a collection of N elements presenting a digraph of N nodes, where\n  the i'th element of Succ represents the successor to node i. The constraint\n  enforces Succ to form a Hamiltonian circuit, a path through every node in\n  the graph, visiting each node once and forming a circuit. Additionally,\n  CostMatrix specifies the cost for traversing between each pair of nodes:\n  CostMatrix[i,j] represents the cost of travelling from node i to j, and \n  Cost is constrained to the total cost for the circuit.\n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</P><P>\n  Note that the Gecode implementation of this constraint has index (node id)\n  starting from 0, rather than 1. This constraint is actually posted\n  as circuit_offset_g/4 with an offset of 1. A version of this constraint\n  with native Gecode indexing is available as circuit_g/3.\n</P><P>\n  ConsistencyModule is the optional module specification to give the \n  consistency level for the propagation for this constraint: \n  gfd_gac for generalised arc consistency (domain consistency), \n  and gfd_vc for value consistency.\n</P><P>\n  This constraint is implemented by Gecode's circuit() constraint (variant with \n  cost), using an offset of 1.\n</P>\n")]).
:- comment(circuit / 4, [amode : circuit(+, ++, +, ?), args : ["Succ" : "A collection of N different variables or integers", "CostMatrix" : "A NxN matrix of integers", "ArcCosts" : "A collection of N variables or integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> circuit(+Succ,++CostMatrix,+ArcCosts,?Cost)", see_also : [circuit / 1, circuit / 3, circuit_g / 4], summary : "Constrains elements in Succ to form a Hamiltonian circuit with cost Cost.", kind : [constraint], eg : "[eclipse 5]: CostM = []([](0,3,5,7),[](4,0,9,6),[](2,1,0,5),[](-7,8,-2,0)),\n        circuit([2,3,4,1], CostM,        [C1,C2,C3,C4], C).\n\nCostM = []([](0, 3, 5, 7), [](4, 0, 9, 6), [](2, 1, 0, 5), [](-7, 8, -2, 0))\nC1 = 3\nC2 = 9\nC3 = 5\nC4 = -7\nC = 10\n", desc : html("<P>  Succ is a collection of N elements presenting a digraph of N nodes, where\n  the i'th element of Succ represents the successor to node i. The constraint\n  enforces Succ to form a Hamiltonian circuit, a path through every node in\n  the graph, visiting each node once and forming a circuit. Additionally,\n  CostMatrix specifies the cost for traversing between each pair of nodes:\n  CostMatrix[i,j] represents the cost of travelling from node i to j, and \n  Cost is constrained to the total Cost for the circuit. The i'th element of \n  ArcCosts is constrained to the cost of the arc in the circuit from node i.\n</P><P>\n  Note that the Gecode implementation of this constraint has index (node id)\n  starting from 0, rather than 1. This constraint is actually posted\n  as circuit_offset_g/5 with an offset of 1. A version of this constraint\n  with native Gecode indexing is available as circuit_g/4.\n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</P><P>\n  ConsistencyModule is the optional module specification to give the \n  consistency level for the propagation for this constraint: \n  gfd_gac for generalised arc consistency (domain consistency), \n  and gfd_vc for value consistency.\n</P><P>\n  This constraint is implemented by Gecode's circuit() constraint (variant with \n  cost and arc costs), using an offset of 1.\n</P>\n")]).
:- comment(circuit_g / 1, [amode : circuit_g(+), args : ["Succ" : "A collection of different variables or integers"], template : "<ConsistencyModule:> circuit_g(+Succ)", summary : "Constrains elements in Succ to form a Hamiltonian circuit, with native Gecode indexing.", see_also : [circuit / 1], kind : [constraint : [extra : [gccat : circuit]]], eg : "\ncircuit_g([A,2,3,0])\n\nA = 1\n\n\n", desc : html("<P>  This version of circuit/1 uses the native Gecode indexing, which starts \n  from 0. This is different from normal ECLiPSe's indexing, which starts \n  from 1, and may be incompatible with existing ECLiPSe code. \n</p><p>\n  See circuit/1 for a more detailed description of this predicate.")]).
:- comment(circuit_g / 3, [amode : circuit_g(+, ++, ?), args : ["Succ" : "A collection of N different variables or integers", "CostMatrix" : "A NxN matrix of integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> circuit_g(+Succ,++CostMatrix,?Cost)", summary : "Constrains elements in Succ to form a Hamiltonian circuit with cost Cost. This version uses native Gecode indexing.", see_also : [circuit / 3], kind : [constraint], eg : "[eclipse 10]: CostM = []([](0,3,5,7),[](4,0,9,6),[](2,1,0,5),[](-7,8,-2,0)),\n        circuit_g([1,2,3,0], CostM, C).   \n\nCostM = []([](0, 3, 5, 7), [](4, 0, 9, 6), [](2, 1, 0, 5), [](-7, 8, -2, 0))\nC = 10\n\n\n[eclipse 6]: CostM = []([](0,3,5,7),[](4,0,9,6),[](2,1,0,5),[](-7,8,-2,0)),\n        C #= circuit([2,3,4,1], CostM) + 1.\n\nCostM = []([](0, 3, 5, 7), [](4, 0, 9, 6), [](2, 1, 0, 5), [](-7, 8, -2, 0))\nC = 11\n\n", desc : html("<P>  This version of circuit/3 uses the native Gecode indexing, which starts \n  from 0. This is different from normal ECLiPSe's indexing, which starts from 1.</p><p>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</P><P>\n  See circuit/3 for a more detailed description of this predicate.")]).
:- comment(circuit_g / 4, [amode : circuit_g(+, ++, +, ?), args : ["Succ" : "A collection of N different variables or integers", "CostMatrix" : "A NxN matrix of integers", "ArcCosts" : "A collection of N variables or integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> circuit_g(+Succ,++CostMatrix,+ArcCosts,?Cost)", summary : "Constrains elements in Succ to form a Hamiltonian circuit with cost Cost, using native Gecode indexing.", see_also : [circuit / 4], kind : [constraint], eg : "CostM = []([](0,3,5,7),[](4,0,9,6),[](2,1,0,5),[](-7,8,-2,0)),\n        circuit_g([1,2,3,0], CostM, [C0,C1,C2,C3], C).\n", desc : html("<P>  This version of circuit/4 uses the native Gecode indexing, which starts \n  from 0. This is different from normal ECLiPSe's indexing, which starts from 1.\n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</p><p>\n  See circuit/4 for a more detailed description of this predicate.")]).
:- comment(circuit_offset / 2, [amode : circuit_offset(+, +), args : ["Succ" : "A collection of different variables or integers", "Offset" : "Offset for Succ (An integer)"], template : "<ConsistencyModule:> circuit_offset(+Succ,+Offset)", summary : "Constrains elements (offset by Offset) in Succ to form a Hamiltonian circuit.", see_also : [circuit_offset_g / 2], kind : [constraint], desc : html("<P>  Succ is a collection of N elements presenting a digraph of N nodes, where\n  the value of the i'th element of Succ - Offset represents the successor to \n  node i. The constraint enforces Succ to form a Hamiltonian circuit,\n  a path through every node in the graph, visiting each node once and\n  forming a circuit.</P><P>\n\n  Note that the Gecode implementation of this constraint has index (node id)\n  starting from 0, rather than 1. The value of Offset is incremented by 1 \n  when the constraint is posted to Gecode.  A version of this constraint with\n  native Gecode indexing, i.e. without adjusting Offset, is available \n  as circuit_offset_g/2.\n</P><P>\n  ConsistencyModule is the optional module specification to give the \n  consistency level for the propagation for this constraint: \n  gfd_gac for generalised arc consistency (domain consistency), \n  and gfd_vc for value consistency.\n</P><P>\n  This constraint is implemented by Gecode's circuit() constraint, using an \n  offset of Offset + 1.\n</P>\n")]).
:- comment(circuit_offset / 4, [amode : circuit_offset(+, +, ++, ?), args : ["Succ" : "A collection of N different variables or integers", "Offset" : "Offset for Succ (An integer)", "CostMatrix" : "A NxN matrix of integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> circuit_offset(+Succ,+Offset,++CostMatrix,?Cost)", summary : "Constrains elements in Succ (offset by Offset) to form a Hamiltonian circuit with cost Cost.", see_also : [circuit_offset_g / 4, circuit_offset / 2, circuit_offset / 5, circuit / 3], kind : [constraint], desc : html("<P>  Succ is a collection of N elements presenting a digraph of N nodes, where\n  the value of the i'th element of Succ - Offset represents the successor to \n  node i. The constraint enforces Succ to form a Hamiltonian circuit,\n  a path through every node in the graph, visiting each node once and\n  forming a circuit. Additionally,CostMatrix specifies the cost for \n  traversing between each pair of nodes:\n  CostMatrix[i,j] represents the cost of travelling from node i to j, and \n  Cost is constrained to the total cost for the circuit.\n</P><P>\n  Note that the Gecode implementation of this constraint has index (node id)\n  starting from 0, rather than 1. The value of Offset is incremented by 1 \n  when the constraint is posted to Gecode.  A version of this constraint with\n  native Gecode indexing, i.e. without adjusting Offset, is available \n  as circuit_offset_g/4.\n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</P><P>\n  ConsistencyModule is the optional module specification to give the \n  consistency level for the propagation for this constraint: \n  gfd_gac for generalised arc consistency (domain consistency), \n  and gfd_vc for value consistency.\n</P><P>\n  This constraint is implemented by Gecode's circuit() constraint (variant with \n  cost), using an offset of Offset + 1.\n</P>\n")]).
:- comment(circuit_offset / 5, [amode : circuit_offset(+, +, ++, +, ?), args : ["Succ" : "A collection of N different variables or integers", "Offset" : "Offset for Succ (An integer)", "CostMatrix" : "A NxN matrix of integers", "ArcCosts" : "A collection of N variables or integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> circuit_offset(+Succ,+Offset,++CostMatrix,+ArcCosts,?Cost)", see_also : [circuit_offset / 2, circuit_offset / 4, circuit_offset_g / 5], summary : "Constrains elements in Succ (offset by Offset) to form a Hamiltonian circuit with cost Cost.", kind : [constraint], desc : html("<P>  Succ is a collection of N elements presenting a digraph of N nodes, where\n  the value of the i'th element of Succ - Offset represents the successor to \n  node i. The constraint enforces Succ to form a Hamiltonian circuit,\n  a path through every node in the graph, visiting each node once and\n  forming a circuit. Additionally,CostMatrix specifies the cost for \n  traversing between each pair of nodes:\n  CostMatrix[i,j] represents the cost of travelling from node i to j, and \n  Cost is constrained to the total cost for the circuit. The i'th element of \n  ArcCosts is constrained to the cost of the arc in the circuit from node i.\n</P><P>\n  Note that the Gecode implementation of this constraint has index (node id)\n  starting from 0, rather than 1. The value of Offset is incremented by 1 \n  when the constraint is posted to Gecode.  A version of this constraint with\n  native Gecode indexing, i.e. without adjusting Offset, is available \n  as circuit_offset_g/5.\n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</P><P>\n  ConsistencyModule is the optional module specification to give the \n  consistency level for the propagation for this constraint: \n  gfd_gac for generalised arc consistency (domain consistency), \n  and gfd_vc for value consistency.\n</P><P>\n  This constraint is implemented by Gecode's circuit() constraint (variant with \n  cost and arc costs), using an offset of Offset + 1.\n</P>\n")]).
:- comment(circuit_offset_g / 2, [amode : circuit_offset_g(+, +), args : ["Succ" : "A collection of different variables or integers", "Offset" : "Offset for Succ (An integer)"], template : "<ConsistencyModule:> circuit_offset_g(+Succ, +Offset)", summary : "Constrains elements (offset by Offset) in Succ to form a Hamiltonian circuit, with native Gecode indexing.", see_also : [circuit_offset / 2], kind : [constraint], desc : html("<P>  This version of circuit_offset/2 uses the native Gecode indexing, which\n  starts from 0. This is different from normal ECLiPSe's indexing, which\n  starts from 1. Offset is not adjusted in this version. This version of \n  the constraint is provided for completeness, in case the user is using\n  native Gecode indexing in their code, so that Offset does not need to\n  be adjusted manually by the user. \n </p><p>\n  See circuit_offset/2 for a more detailed description of this predicate.")]).
:- comment(circuit_offset_g / 4, [amode : circuit_offset_g(+, +, ++, ?), args : ["Succ" : "A collection of N different variables or integers", "Offset" : "Offset for Succ (An integer)", "CostMatrix" : "A NxN matrix of integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> circuit_offset_g(+Succ,+Offset,++CostMatrix,?Cost)", summary : "Constrains elements in Succ (offset by Offset) to form a Hamiltonian circuit with cost Cost. This version uses native Gecode indexing.", see_also : [circuit_offset / 4], kind : [constraint], desc : html("<P>  This version of circuit_offset/4 uses the native Gecode indexing, which\n  starts from 0. This is different from normal ECLiPSe's indexing, which\n  starts from 1. Offset is not adjusted in this version. This version of \n  the constraint is provided for completeness, in case the user is using\n  native Gecode indexing in their code, so that Offset does not need to\n  be adjusted manually by the user. \n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</p><p>\n  See circuit_offset/4 for a more detailed description of this predicate.")]).
:- comment(circuit_offset_g / 5, [amode : circuit_offset_g(+, +, ++, +, ?), args : ["Succ" : "A collection of N different variables or integers", "Offset" : "Offset for Succ (An integer)", "CostMatrix" : "A NxN matrix of integers", "ArcCosts" : "A collection of N variables or integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> circuit_offset_g(+Succ,+Offset,++CostMatrix,+ArcCosts,?Cost)", summary : "Constrains elements in Succ (offset by Offset) to form a Hamiltonian circuit with cost Cost, using native Gecode indexing.", see_also : [circuit_offset / 5], kind : [constraint], desc : html("<P>  This version of circuit_offset/5 uses the native Gecode indexing, which starts \n  from 0. This is different from normal ECLiPSe's indexing, which starts from 1.\n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</p>")]).
:- comment(count / 4, [summary : "Constrain the number of occurrence of Value in Vars (Occ) to satisfy  the relation Occ Rel N", amode : count(+, +, +, +), amode : count(?, +, +, +), amode : count(?, +, +, ?), amode : count(+, +, +, ?), template : "<ConsistencyModule:> count(+Value, ?Vars, +Rel, ?N)", args : ["+Value" : "An integer (or a domain variable)", "?Vars" : "A collection (a la collection_to_list/2) of domain variables or integers", "+Rel" : "One of the atom: #>, #>=, #<, #=<, #=, #\\=", "?N" : "An integer or domain variable"], kind : [constraint : [extra : [gccat : count]]], eg : "\n[eclipse 33]: count(5, [](4,5,5,4,5), (#>=), 2).   % succeed\n\n[eclipse 34]:  count(5, [](4,5,5,4,5), (#>), 2).   % succeed\n\n[eclipse 35]: count(5, [](4,5,5,4,5), (#=), 2).    % fail\n\n[eclipse 36]: count(5, [](4,5,5,4,5), (#\\=), 2).   % succeed\n\n[eclipse 37]: count(5, [](4,5,5,4,5), (#=<), 2).   % fail\n\n[eclipse 38]: count(5, [](4,5,5,4,5), (#<), 2).    % fail\n\n[eclipse 39]: count(5, [](4,5,5,4,5), (#>=), 3).   % succeed\n\n[eclipse 40]: count(5, [](4,5,5,4,5), (#>), 3).    % fail\n\n[eclipse 41]: count(5, [](4,5,5,4,5), (#=), 3)     % succeed\n\n[eclipse 42]: N :: [3,5], count(3, [3,A,3,5,3,3], (#=), N).\n\nN = 5\nA = 3\n\n[eclipse 43]:  N :: [3,5], count(3, [3,A,3,5,3], (#=), N).\n\nN = 3\nA = A{[-1000000 .. 2, 4 .. 1000000]}\n\n[eclipse 44]:  N :: [3,5], count(3, [3,A,3,5,3], (#<), N).\n\nN = 5\nA = A{[-1000000 .. 1000000]}\n\n[eclipse 45]:  N :: [3,5], count(3, [3,A,3,5,3], (#>), N).\n\nN = 3\nA = 3\n\n[eclipse 46]:  N :: [3,5], count(3, [3,A,3,5,3], (#>=), N).\n\nN = 3\nA = A{[-1000000 .. 1000000]}\n\n[eclipse 47]: N :: [3,5], count(3, [3,A,3,5,3], (#=<), N).\n\nN = N{[3, 5]}\nA = A{[-1000000 .. 1000000]}\n\n[eclipse 48]: N :: [3,5], count(3, [3,A,3,5,3], (#\\=), N).\n\nN = N{[3, 5]}\nA = A{[-1000000 .. 1000000]}\n\n", desc : html("<P>   Constrain the number of occurrences of Value in Vars to satisfy the\n   constraint defined by Rel:\n<PRE>\n          <number of occurrences of Value in Vars> Rel N\n</PRE><P>\n   Rel can be one of #&gt;, #&gt;=, #&lt;, #=&lt;, #=, #\\= (or equivalently,\n   &gt;, &gt;=, &lt;, =&lt;, =, \\=).\n</P><P>\n   occurrences/3, atmost/3, atleast/3 are defined using count/3. For example,\n<PRE>\n         atmost(N, Vars, Value)\n</PRE>\n   is defined by:\n<PRE>\n        count(Value, Vars, (#=<), N)\n</PRE><P>\n   This constraint can be embedded in a constraint expression in its\n   functional form (without the last argument).\n</P><P>\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_gac for domain (generalised arc) consistency. Note that if\n   Value is a domain variable, then the propagation is weak, achieving\n   neither domain or bound consistency until Value becomes ground.\n</P><P>\n   This constraint is known as count in the global constraint catalog.\n   It is implemented using gecode's count() constraint (variants with\n   int or IntVar for argument representing Value).\n</p>\n")]).
:- comment(count_matches / 4, [summary : "The number of the elements in Vars that\n match its corresponding value in Values, Matches, satisfies the\n relation Matches Rel N.", template : "<ConsistencyModule:> count_matches(+Values, ?Vars, +Rel, ?N)", args : ["+Values" : "A collection of M integer values", "?Vars" : "A collection of M domain variables or integers", "+Rel" : "One of the atom: #>, #>=, #<, #=<, #=, #\\=", "?N" : "An integer or domain variable"], kind : [constraint], eg : "[eclipse 5]: count_matches([1,2,3,4], [A,B,C,D], (#=), N).\n\nA = A{[-1000000 .. 1000000]}\nB = B{[-1000000 .. 1000000]}\nC = C{[-1000000 .. 1000000]}\nD = D{[-1000000 .. 1000000]}\nN = N{[0 .. 4]}\n\n[eclipse 6]: L = [A,B,C,D], L :: 4..10, count_matches([1,2,3,4], L, (#=), N).\n\nL = [A{[4 .. 10]}, B{[4 .. 10]}, C{[4 .. 10]}, D{[4 .. 10]}]\nA = A{[4 .. 10]}\nB = B{[4 .. 10]}\nC = C{[4 .. 10]}\nD = D{[4 .. 10]}\nN = N{[0, 1]}\n\n[eclipse 15]: count_matches([1,2,3,4], [4,3,2,1], (#=), N).\n\nN = 0\n\n[eclipse 16]: count_matches([1,2,3,4], [2,2,3,5],  (#=), N).\n\nN = 2\n\n[eclipse 17]:  count_matches([], [], (#=), N).\n\nN = 0\n\n", desc : html("<P>   Values and Vars are collections of the same size, and the\n   number of elements in Vars taking on the value given by its corresponding \n   element in Values, Matches, is constrained by the relation:\n<PRE>\n          <Matches> Rel N\n</PRE><P>\n   Rel can be one of #&gt;, #&gt;=, #&lt;, #=&lt;, #=, #\\= (or equivalently,\n   &gt;, &gt;=, &lt;, =&lt;, =, \\=).\n</P><P>\n   This constraint can be embedded in a constraint expression in its\n   functional form (without the last argument).\n</P><P>\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_gac for domain (generalised arc) consistency. \n</P><P>\n   This constraint is implemented by gecode's count() constraint \n   (variant with an IntArgs for Values). \n</P>\n")]).
:- comment(cumulative / 4, [amode : cumulative(+, +, +, +), args : ["StartTimes" : "Collection of start times for tasks (integer variables or integers)", "Durations" : "Collection of duration for tasks (non-negative integer variables or integers)", "Usages" : "Collection of resource usages (positive integers)", "ResourceLimit" : "Maximum amount of resource available (integer variable)"], summary : "Single resource cumulative constraint on scheduling tasks.", see_also : [disjunctive / 2, cumulative_optional / 5, cumulatives / 5, collection_to_list / 2, _94575 : cumulative / 4], kind : [constraint : [extra : [gccat : cumulative]]], eg : "\n\n% success (peak consumption is 7) \n[eclipse 7]: cumulative([1,2,3,6,7], [3,9,10,6,2], [1,2,1,1,3], 8).\n\n% fail (peak consumption is 7)\n[eclipse 8]:  cumulative([1,2,3,6,7], [3,9,10,6,2], [1,2,1,1,3], 6).\n\n", desc : html("<P>\n   A cumulative scheduling constraint. StartTimes, Durations and Usages \n   are collections (a la collection_to_list/2) of equal size N representing\n   N tasks. Durations are non-negative, Usages and ResourceLimit are \n   strictly positive. The declarative meaning is:\n</P><P>\n   The N tasks, each starting at a certain start time, having\n   a certain duration and consuming a certain (constant) amount of\n   resource, then the sum of resource usage of all the tasks does not\n   exceed ResourceLimit at any time. \n</P><P>\n   A zero duration task both consume and release the resource it uses\n   at the same time-point, so effectively it does not consume any resources \n   at that time-point, but there must be sufficient resources available at \n   that time-point to allow the task to be scheduled.\n</P><P>\n   Note that the constraint is implemented by different Gecode propagators,\n   depending on if Durations contains domain variables or not. If\n   Durations does have domain variables, the Gecode propagator requires\n   an extra End domain variable specifying the end time, and a constraint \n<PRE>        \n     End #= Start + Duration  \n</PRE>\n   for each task. These are posted as part of the constraint (the End \n   variables are not accessible by the user).\n</P><P>\n   Any input variables which are not already domain variables are turned\n   into domain variables with default domain.\n</P><P>\n    This constraint is also known as cumulative in the global constraint\n    catalog, but in the catalog, tasks with zero duration have a different\n    definition of overlap with other tasks. The consreaint is implemented \n    using Gecode's cumulative constraint (with extra constraints on task \n    end-times if any task duration is a domain variable).\n</P>")]).
:- comment(cumulative_optional / 5, [amode : cumulative_optional(+, +, +, +, +), args : ["StartTimes" : "Collection of start times for tasks (integer variables or integers)", "Durations" : "Collection of duration for tasks (non-negative integer variables or integers)", "Usages" : "Collection of resource usages (positive integers)", "ResourceLimit" : "Maximum amount of resource available\n                            (integer variable)", "Scheduled" : "Collection of N scheduled booleans for task (0/1 domain variables or integers)"], summary : "Single resource cumulative constraint on scheduling optional tasks.", see_also : [disjunctive / 2, disjunctive_optional / 3, cumulative / 4, collection_to_list / 2, _95984 : cumulative / 4], kind : [constraint], desc : html("<P>\n   A cumulative scheduling constraint. StartTimes, Durations, Usages and \n   Scheduled are collections (a la collection_to_list/2) of equal size N,\n   representing N task. Durations must be non-negative, Usages and \n   ResourceLimit must be strictly positive, and Scheduled are booleans \n   (values of 0/1). The declarative meaning is:\n</P><P>\n   The N tasks, each starting at a certain start time, having\n   a certain duration and consuming a certain (constant) amount of\n   resource, then the sum of resource usage of all the tasks does not\n   exceed ResourceLimit at any time. A task would not be scheduled \n   if its Scheduled boolean is 0, and must be scheduled if 1.\n/P><P>\n   A zero duration task both consume and release the resource it uses\n   at the same time-point, so effectively it does not consume any resources \n   at that time-point, but there must be sufficient resources available at \n   that time-point to allow the task to be scheduled.\n<</P><P>\n   Note that the constraint is implemented by different Gecode propagators,\n   depending on if Durations contains domain variables or not. If\n   Durations does have domain variables, the Gecode propagator requires\n   an extra End domain variable specifying the end time, and a constraint \n<PRE>        \n     End #= Start + Duration  \n</PRE>\n   for each task. These are posted as part of the constraint (the End \n   variables are not accessible by the user).\n</P><P>\n   Any input variables which are not already domain variables are turned\n   into domain variables with default domain.\n</P>\n")]).
:- comment(cumulatives / 5, [amode : cumulatives(+, +, +, +, ++), template : "<ConsistencyModule:> cumulatives(+StartTimes, +Durations, +Heights, +Assigned, +MachineCapacities)", args : ["StartTimes" : "Collection of N start times for tasks (domain variables or integers)", "Durations" : "Collection of N duration for tasks (domain variables or integers)", "Heights" : "Collection of N resource usages (positive) or productions (negative) by tasks (domain variables or integers) with the assigned machine", "Assigned" : "Collection of N ID of machine assigned to tasks (domain variables or integers)", "MachineCapacities" : "Collection of M maximum amount of resource available for machines (integers)"], summary : "Multi-resource cumulatives constraint on specified tasks.", see_also : [disjunctive / 2, cumulative / 4, collection_to_list / 2, cumulatives_g / 5], kind : [constraint : [extra : [gccat : cumulatives]]], eg : "\n[eclipse 4]: cumulatives([2,1,4,2,5,3,1],[2,4,2,3,2,2,4],[-2,1,-1,2,2,-1,1], \n                [1,1,1,1,1,2,2], [2,1]).  % Succeed\n\n[eclipse 5]: cumulatives([2,1,4,2,5,3,1],[2,4,2,3,2,2,4],[-2,1,-1,2,2,-1,1], \n                [1,1,1,1,1,2,2], [1,1]).  % Fails\n", desc : html("<P>\n   A multi-resource cumulatives scheduling constraint - scheduling of M\n   machines providing resources for N tasks. StartTimes, Durations, Heights \n   and Assigned are collections (a la collection_to_list/2) of equal size N \n   of domain variables or integers. MachineLimits is a collection of M \n   integers. The declarative meaning is:\n   If there are N tasks and M machines, each machine having a limit of \n   resource that can be consumed at any single time-point, and each task \n   starting at a certain start time, having a certain duration and \n   consuming/producing a certain (constant) amount of resource for the \n   machine assigned to the task, then the sum of resource usage for each\n   machine by all the tasks does not exceed the capacity for that machine at\n   any time. \n</P><P>\n   Any input variables which are not already domain variables are turned\n   into domain variables with default domain.\n</P><P>\n   This constraint generalise the cumulative constraint to multi-resources,\n   and is also more flexible, in that tasks can both produce and consume a\n   resource.\n</P><P>\n    Note that the Gecode implementation of this constraint has index starting\n    from 0, i.e. the numbering for the machines starts from 0. These native \n    indices are mapped to the  ECLiPSe indices starting from 1 with an \n    additional dummy zero'th machine that is not used. A version of this \n    constraint that uses native Gecode indexing is available \n    as cumulatives_g/5.\n</P><P>\n    ConsistencyModule is the optional module specification to give the \n    consistency level for the propagation for this constraint: \n    gfd_vc for value consistency.\n</P><P>\n    This constraint is also known as cumulatives in the global constraint\n    catalog, where CTR is \"less than or equal to\" case  The consreaint is \n    implemented using Gecode's cumulatives constraint (with extra constraints \n    on task end-times if any task duration is a domain variable).\n</P>")]).
:- comment(cumulatives_g / 5, [amode : cumulatives_g(+, +, +, +, ++), template : "<ConsistencyModule:> cumulatives_g(+StartTimes, +Durations, +Heights, +Assigned, +MachineCapacities)", args : ["StartTimes" : "Collection of N start times for tasks (domain variables or integers)", "Durations" : "Collection of N duration for tasks (domain variables or integers)", "Heights" : "Collection of N resource usages (positive) or productions (negative) by tasks (domain variables or integers) with the assigned machine", "Assigned" : "Collection of N ID of machine assigned to tasks (domain variables or integers)", "MachineCapacities" : "Collection of M maximum amount of resource available for machines (integers)"], summary : "Multi-resource cumulatives constraint on specified tasks, using native Gecode indexing.", see_also : [cumulatives / 5], kind : [constraint : [extra : [gccat : cumulatives]]], desc : html("  This version of the constraint uses the native Gecode indexing, which starts \n  from 0. This is different from normal ECLiPSe's indexing, which starts from 1.\n</p><p>\n  This predicate maps more directly to Gecode's native implementation of \n  the constraint, without the conversion between Gecode and ECLiPSe\n  indexing of cumulatives/5. It may therefore be more efficient, but could \n  also be incompatible with existing ECLiPSe code. \n</p><p>\n  See cumulatives/5 for a more detailed description of this predicate.")]).
:- comment(cumulatives_min / 5, [amode : cumulatives_min(+, +, +, +, ++), template : "<ConsistencyModule:> cumulatives_min(+StartTimes, +Durations, +Heights, +Assigned, +MachineConsumptions)", args : ["StartTimes" : "Collection of N start times for tasks (domain variables or integers)", "Durations" : "Collection of N duration for tasks (domain variables or integers)", "Heights" : "Collection of N resource usages (positive) or productions (negative) by tasks (domain variables or integers) with the assigned machine", "Assigned" : "Collection of N ID of machine assigned to tasks (domains variables or integers)", "MachineConsumptions" : "Collection of M minimum amount of resource consumptions for machines (integers)"], summary : "Multi-resource cumulatives constraint on specified tasks with required minimum resource consumptions.", see_also : [disjunctive / 2, cumulatives / 5, collection_to_list / 2, cumulative / 4], kind : [constraint : [extra : [gccat : cumulatives]]], eg : "\n\n[eclipse 7]: cumulatives_min([2,1,4,2,5,3,1],[-2,4,2,3,2,2,4],\n                [2,1,-1,2, 2,-1,1], [1,1,1,1,1,2,2], [1,0]).  % Succeed\n \n[eclipse 8]: cumulatives_min([2,1,4,2,5,3,1],[2,4,2,3,2,2,4],\n                [-2,1,-1,2,2,-1,1], [1,1,1,1,1,2,2], [1,1]). % fails \n\n\n", desc : html("<P>\n   A multi-resource cumulatives scheduling constraint - scheduling of M\n   machines providing resources for N tasks. StartTimes, Durations, Heights \n   and Assigned are collections (a la collection_to_list/2) of equal size N \n   of domain variables or integers. MinUsages is a collection of M \n   integers. The declarative meaning is:\n   If there are N tasks and M machines, each machine having a minimum of \n   produce that must be consumed at any single time-point, and each task \n   starting at a certain start  time, having a certain duration and \n   consuming/producing a certain (constant) amount of produce for the \n   machine assigned to the task, then the sum of resource consumption for each\n   machine by all the tasks must be at least the minimum for that machine at\n   any time. \n</P><P>\n   Any input variables which are not already domain variables are turned\n   into domain variables with default domain.\n</P><P>\n   This constraint generalise the cumulative constraint to multi-resources,\n   and is also more flexible, in that tasks can both produce and consume a\n   resource.\n</P><P>\n    Note that the Gecode implementation of this constraint has index starting\n    from 0, i.e. the numbering for the machines starts from 0. These native \n    indices are mapped to the  ECLiPSe indices starting from 1 with an \n    additional dummy zero'th machine that is not used. A version of this \n    constraint that uses native Gecode indexing is available \n    as cumulatives_min_g/5.\n</P><P>\n    ConsistencyModule is the optional module specification to give the \n    consistency level for the propagation for this constraint: \n    gfd_vc for value consistency.\n</P><P>\n    This constraint is known as cumulatives in the global constraint\n    catalog, where CTR is \"greater than or equal to\" case  The consreaint is \n    implemented using Gecode's cumulatives constraint (with extra constraints \n    on task end-times if any task duration is a domain variable).\n</P>")]).
:- comment(cumulatives_min_g / 5, [amode : cumulatives_min_g(+, +, +, +, ++), template : "<ConsistencyModule:> cumulatives_min_g(+StartTimes, +Durations, +Heights, +Assigned, +MachineConsumptions)", args : ["StartTimes" : "Collection of N start times for tasks (domain variables or integers)", "Durations" : "Collection of N duration for tasks (domain variables or integers)", "Heights" : "Collection of N resource usages (positive) or productions (negative) by tasks (domain variables or integers) with the assigned machine", "Assigned" : "Collection of N ID of machine assigned to tasks (domains variables or integers)", "MachineConsumptions" : "Collection of M minimum amount of resource consumptions for machines (integers)"], summary : "Multi-resource cumulatives constraint on specified tasks with required minimum resource consumptions, using native Gecode indexing.", see_also : [cumulatives_min / 5], kind : [constraint : [extra : [gccat : cumulatives]]], desc : html("  This version of the constraint uses the native Gecode indexing, which starts \n  from 0. This is different from normal ECLiPSe's indexing, which starts from 1.\n</p><p>\n  This predicate maps more directly to Gecode's native implementation of \n  the constraint, without the conversion between Gecode and ECLiPSe\n  indexing of cumulatives_min/5. It may therefore be more efficient, but \n  could also be incompatible with existing ECLiPSe code. \n</p><p>\n  See cumulatives_min/5 for a more detailed description of this predicate.")]).
:- comment(disjoint2 / 1, [amode : disjoint2(+), args : ["Rectangles" : "Collection of rect{} structures specifying\n the position and size of rectangles on a grid."], summary : "Constrains the position (and possibly size) of the rectangles in Rectangles so that none overlaps.", see_also : [disjoint2_optional / 1, collection_to_list / 2], kind : [constraint : [extra : [gccat : diffn]]], eg : "[eclipse 17]: disjoint2([rect{x:2,y:1,w:2,h:3},rect{x:4,y:3,w:4,h:3},\n                   rect{x:9,w:2,y:4,h:3}]).    % succeed\n\n", desc : html("<P>\n    A two dimensional disjunctive constraint that constrains the replacement\n    of a collection of rectangles specified by Rectangles to not overlap in\n    their areas. \n</P><P>\n    Each rectangle is defined by a rect named structure, using the\n    following fields:\n<DL>\n      <DT>x:<DD> The x co-ordinate of the left side of the rectangle \n      <DT>y:<DD> The y co-ordinate of the bottom side of the rectangle.\n      <DT>w:<DD> The width of the rectangle\n      <DT>h:<DD> The height of the rectangle\n</DL>\n    x, y, w, h can be domain variables or integers. If w and h are\n    integers, then the rectangle is of a fixed size. Note the rect{}\n    structure has an additional 'o' field, which is ignored for this\n    constraint as it is only used for disjoint2_optional/1.\n</P><P>\n    Note that the constraint is implemented by different Gecode propagators,\n    depending on if all the rectangles are of fixed size or not. If at\n    least one rectangle is not of fixed size, then the Gecode\n    propagator requires additional variables for the right and top\n    sides of the rectangles, plus additional constraints\n<PRE>        \n      Xright #= Xleft + Width\n      Ytop   #= Ybot + Height\n</PRE>\n    for each rectangles. These are posted as part of the constraint (the Xright \n    and Ytop variables are not accessible by the user).\n</P><P>\n    Any input variables which are not already domain variables will be\n    converted into domain variables with default bounds.\n</P><P>\n    A version of this constraint, generalised from two to multi-\n    dimension, is known as diffn in the Global Constraint Catalog.\n</P><P>\n    This constraint is implemented using Gecode's nooverlap() constraint.\n</P>\n")]).
:- comment(disjoint2_optional / 1, [amode : disjoint2_optional(+), args : ["Rectangles" : "Collection of rect{} structures specifying\n the position and size of rectangles on a grid."], summary : "Constrains the position (and possibly size) of the (possibly optional) rectangles in Rectangles so that none overlaps.", see_also : [disjoint2 / 1, collection_to_list / 2], kind : [constraint], desc : html("<P>\n    A two dimensional disjunctive constraint that constrains the replacement\n    of a collection of rectangles specified by Rectangles to not overlap in\n    their areas. The placement of each rectangle can be optional, i.e.\n    they may not need to be placed.\n</P><P>\n    Each rectangle is defined by a rect named structure, using the\n    following fields:\n<DL>\n      <DT>x:<DD> The x co-ordinate of the left side of the rectangle \n      <DT>y:<DD> The y co-ordinate of the bottom side of the rectangle.\n      <DT>w:<DD> The width of the rectangle\n      <DT>h:<DD> The height of the rectangle\n      <DT>b:<DD> Boolean specifying if rectangle is placed or not\n</DL>\n    x, y, w, h can be domain variables or integers. If w and h are\n    integers, then the rectangle is of a fixed size. o is a 0/1\n    integer or domain variable, 1 specifies that the rectangle needs\n    to be placed, and 0 that it is not placed. \n</P><P>\n    Note that the constraint is implemented by different Gecode propagators,\n    depending on if all the rectangles are of fixed size or not. If at\n    least one rectangle is not of fixed size, then the Gecode\n    propagator requires additional variables for the right and top\n    sides of the rectangles, plus additional constraints\n<PRE>        \n      Xright #= Xleft + Width\n      Ytop   #= Ybot + Height\n</PRE>\n    for each rectangles. These are posted as part of the constraint (the Xright \n    and Ytop variables are not accessible by the user).\n</P><P>\n    Any input variables which are not already domain variables will be\n    converted into domain variables with default bounds.\n</P><P>\n    A version of this constraint, generalised from two to multi-\n    dimension, and without optional placement, is known as diffn in\n    the Global Constraint Catalog. It is implemented using Gecode's \n    nooverlap() constraint (variant with optional placement).\n</P>")]).
:- comment(disjunctive / 2, [amode : disjunctive(+, +), args : ["StartTimes" : "Collection of N start times for tasks (domain variables or integers)", "Durations" : "Collection of N durations for tasks (non-negative domain variables or integers)"], summary : "Constrain the tasks with specified start times and durations to not overlap in time.", see_also : [_90542 : disjunctive / 2, disjunctive_optional / 3, cumulative / 4, cumulatives / 5, collection_to_list / 2], kind : [constraint : [extra : [gccat : disjunctive]]], eg : "\n[eclipse 2]: disjunctive([1,7,4],[3,2,1]).    % succeed\n\n[eclipse 3]: disjunctive([1,7,3], [3,2,1]).   % fail\n\n[eclipse 4]: disjunctive([1,4,7,4],[3,0,2,1]). % succeed \n\n[eclipse 5]: disjunctive([1,2,7,4],[3,0,2,1]). % fail \n\n\n[eclipse 5]: [S2,S4]::[1..9], disjunctive([1,S2,7,S4], [3,1,2,1]).\n\nS2 = S2{[4 .. 9]}\nS4 = S4{[4 .. 9]}\n\n", desc : html("<P>\n    A disjunctive scheduling constraint. StartTimes and Durations are\n    collections (a la collection_to_list/2) of equal size N of integer\n    variables or integers. Durations must be non-negative.\n </P><P>\n    The declarative meaning is that the N tasks with the given start \n    times and durations do not overlap at any point in time, i.e. for\n    any pairs of tasks X and Y, the following holds:\n<PRE>\n        (Xstart + Xduration =< Ystart) or (Ystart + Yduration =< Xstart)\n</PRE></P><P>\n    Note that the constraint is implemented by different Gecode propagators,\n    depending on if Durations contains domain variables or not. If\n    Durations does have domain variables, the Gecode propagator requires\n    an extra End domain variable specifying the end time, and a constraint \n<PRE>        \n      End #= Start + Duration  \n</PRE>\n    for each task. These are posted as part of the constraint (the End \n    variables are not accessible by the user).\n</P><P>\n    Any input variables which are not already domain variables will be\n    converted into domain variables with default bounds.\n</P><P>\n    This constraint is also known as disjunctive in the global constraint\n    catalog, but in the catalog, tasks with zero duration are allowed\n    to overlap with other tasks. The consreaint is implemented using \n    Gecode's unary constraint (with extra constraints on task end times if \n    any task duration is a domain variable).\n</P>\n")]).
:- comment(disjunctive_optional / 3, [amode : disjunctive_optional(+, +, +), args : ["StartTimes" : "Collection of N start times for tasks (domain variables or integers)", "Durations" : "Collection of N durations for tasks (non-negative domain variables or integers)", "Scheduled" : "Collection of N scheduled booleans for task (0/1 domain variables or integers)"], summary : "Constrain the optional tasks with specified start times and durations to not overlap in time.", see_also : [disjunctive / 2, collection_to_list / 2], kind : [constraint], desc : html("<P>  \n    A disjunctive scheduling constraint. StartTimes, Durations and Scheduled\n    are collections (a la collection_to_list/2) of equal size N. Durations\n    must be non-negative, and Scheduled are booleans (0/1).\n    The declarative meaning is that the scheduled tasks with the given start \n    times and durations do not overlap at any point in time. A task would not\n    be scheduled if its Scheduled boolean is 0, and must be scheduled if 1.\n</P><P>\n    Note that the constraint is implemented by different Gecode propagators,\n    depending on if Durations contains domain variables or not. If\n    Durations does have domain variables, the Gecode propagator requires\n    an extra End domain variable specifying the end time, and a constraint \n<PRE>        \n      End #= Start + Duration  \n</PRE>\n    for each task. These are posted as part of the constraint (the End \n    variables are not accessible by the user).\n</P><P>\n    Any input variables which are not already domain variables will be\n    converted into domain variables with default bounds.\n</P><P>\n    This constraint is implemented using Gecode's unary() constraint (with \n    extra constraints on task end times if any task duration is a domain \n    variable).\n</P>\n")]).
:- comment(divmod / 4, [summary : "Constrains Q to X // Y, and M to X mod Y.", template : "<ConsistencyModule:> divmod(?X,?Y,?Q,?M)", amode : divmod(?, ?, ?, ?), args : ["X" : "An integer or domain variable", "Y" : "An integer or domain variable", "Q" : "An integer or domain variable", "M" : "An integer or domain variable"], kind : [constraint], desc : html("   Constrains Q to be the integer quotient of X and Y (X // Y), and M to\n   be the modulus of X and Y (X mod Y). Q is rounded towards 0.\n   </P><P> \n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency.\n</P>\n")]).
:- comment(element / 3, [summary : "Value is the Index'th element of the integer collection Collection.", template : "<ConsistencyModule:> element(?Index, +Collection, ?Value)", args : ["?Index" : "A domain variable or an integer.", "+Collection" : "A non-empty collection of integers or domain variable.", "?Value" : "A domain variable or an integer."], fail_if : "Fails if Value is not the Index'th element of Collection.", kind : [constraint : [extra : [gccat : element]]], see_also : [element_g / 3, _46602 : element / 3], desc : html("This constraint can be used in a variety of programs to state a\n   relation between two domain variables.  Collection is a collection of \n   integers and the constraint states that its Index'th element is equal to \n   Value, i.e.\n<P>\n<PRE>\n\t\t\t     Collection_Index = Value\n</PRE>\n   the domain of the other variable is updated accordingly. Index starts from 1.\n<P>\n   Note that unlike the element constraint in IC, the values in Collection \n   can be domain variables as well as integers. Also note that the actual\n   Gecode constraint has an index that starts from 0 - a dummy element\n   is added to start of Collection to map Index to ECLiPSe style index\n   starting from 1. A version of this constraint that uses the native \n   Gecode indexing is element_g/3. \n<P>\n   This constraint can be embedded in a constraint expression in its\n   functional form (without the last argument).\n<P>\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency.\n</P><P> \n   This constraint is known as element in the global constraint catalog,\n   and is implemented with Gecode's element() constraint.\n</P>\n"), eg : "\n[eclipse 2]: element(I, [1,3,6,3], V).\n\nI = I{[1 .. 4]}\nV = V{[1, 3, 6]}\n\n\n[eclipse 2]: element(I, [1,3,6,3], V),  V #\\= 3.\n\nI = I{[1, 3]}\nV = V{[1, 6]}\n\n[eclipse 2]:  X :: [1..10], gfd_gac: element(I, [1,X,6,3],  V), V #\\= 3.\n\n\nZ = Z{[1 .. 10]}\nI = I{[1 .. 3]}\nV = V{[1, 2, 4 .. 10]}\n\n\n"]).
:- comment(element_g / 3, [summary : "Value is the Index'th element of the integer list List, with native Gecode indexing.", template : "<ConsistencyModule:> element_g(?Index, ++List, ?Value)", args : ["?Index" : "A domain variable or an integer.", "+Collection" : "A non-empty collection of integers or domain variable.", "?Value" : "A domain variable or an integer."], fail_if : "Fails if Value is not the Index'th element of Collection.", see_also : [element / 3], kind : [constraint : [extra : [gccat : element]]], desc : html("  This version of element/3 uses the native Gecode indexing, which starts \n  from 0, i.e. the first element of Collection has index 0. This is different \n  from normal ECLiPSe's indexing, which starts from 1.\n</p><p>\n  This predicate maps directly to Gecode's native implementation of the\n  constraint, and may therefore be more efficient, but could also be\n  incompatible with existing ECLiPSe code. \n</P><P>\n   This constraint can be embedded in a constraint expression in its\n   functional form (without the last argument).\n</p><p>\n  See element/3 for a more detailed description of this predicate.")]).
:- comment(exclude / 2, [amode : exclude(?, ++), args : ["Var" : "Domain variable or integer", "Excl" : "Integer value to exclude"], summary : "Exclude the element Excl from the domain of Var.", see_also : [exclude_range / 3, impose_min / 2, impose_max / 2, impose_domain / 2], kind : [dom], desc : html("<P>\n   This predicate is mainly provided for compatibility with IC solver.\n   If you want to remove multiple values from the domain of one or \n   more variables, it is more efficient to use the lib(gfd) specific \n   gfd_vars_exclude/2.\n</P><P>\n   Primitive for excluding an element from the domain of a variable.\n   The call may fail (when Var is the same integer as Excl),\n   succeed (possibly updating the variable's domain), or instantiate the\n   variable (when Excl was one of only two domain elements left).</P><P>\n</P><P>\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, exclude/2 does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n</P>\n")]).
:- comment(exclude_range / 3, [amode : exclude_range(?, ++, ++), args : ["Var" : "Domain variable or integer", "Lo" : "Integer lower bound of range to exclude", "Hi" : "Integer upper bound of range to exclude"], summary : "Exclude the elements Lo..Hi from the domain of Var.", see_also : [exclude / 2, impose_min / 2, impose_max / 2], kind : [dom], desc : html("<P>\n   This predicate is mainly provided for compatibility with IC solver.\n   If you want to exclude the same range of values from multiple variables,\n   it is more efficient to use the lib(gfd) specific gfd_vars_exclude_range/3.\n</P><P>\n   Primitive for excluding the integers between Lo and Hi (inclusive) from\n   the domain of an integer variable.  The call may fail (when the domain of\n   Var has no elements outside the range Lo..Hi), succeed (possibly updating\n   the variable's domain), or instantiate the variable (in the case where\n   the domain gets restricted to a singleton value).</P><P>\n</P><P>\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, exclude_range/3 does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n</P>\n")]).
:- comment(extensional / 4, [template : "<ConsistencyModule:> extensional(+Vars, ++Transitions, +Start, +Finals)", summary : "Constrain Vars' solutions to conform to the finite-state automaton specified by Transitions with start state Start and  final states Finals.", amode : extensional(+, ++, +, ++), args : ["Vars" : "Collection of domain variables or integers,\n or a collection of a collection domain variables or integers", "Transitions" : "A collection of transitions of the form trans{f,l,t)", "Start" : "Start state (non-negative integer)", "Finals" : "Final states (collection of non-negative integers)"], kind : [constraint], eg : "\n[eclipse 7]: L = [A,B,C,D,E], extensional(L, [trans(0,0,0),trans(0,1,1),trans(1,0,0)], 0, [0]), labeling(L), writeln(L), fail.\n[0, 0, 0, 0, 0]\n[0, 0, 0, 1, 0]\n[0, 0, 1, 0, 0]\n[0, 1, 0, 0, 0]\n[0, 1, 0, 1, 0]\n[1, 0, 0, 0, 0]\n[1, 0, 0, 1, 0]\n[1, 0, 1, 0, 0]\n\nNo (0.00s cpu)\n\n", see_also : [regular / 2, table / 2, table / 3], desc : html("   extensional is a user defined constraint, i.e. the solutions for each \n   posted constraint is defined within the constraint. For extensional, \n   the solutions is defined by the deterministic finite-state automaton (DFA)\n   specified by the transitions in Transitions with start state Start and \n   final states Finals.The DFA defines the sequence of values that the \n   variables for the constraint can take. \n</p><p>\n   Vars represents the variables that are to be satisfied for this\n   constraint. It can be one collection of variables (or integers),\n   or a collection of a collections of variables (or integers), if\n   the constraint is to be satisfied by more than one collection of \n   variables. Each collection can be of different size, i.e. have\n   different number of variables. Posting the constraint with multiple \n   collections of variables is logically equivalent to posting individual \n   constraint with the same DFA for each collection, but should be more\n   efficient as the same is shared by all the collections.\n</p><p>\n   A collection of variables in Vars represents a sequence (i.e. they\n   are ordered), and the DFA describes the values that can be taken by\n   the sequence of variables, starting from the first variable, the\n   DFA starts at the Start state, and moves to the next variable in\n   the sequence via a transition given in Transition. A transition is\n   a triple (from,to,input) that specifies the move from one state of the \n   DFA to another (from,to), accompanied by the labelling of the original\n   variable with the value specified by input. A transition is specified  \n   using the named structure trans(f,l,t), for the transition from\n   state f to t (states are non-negative integers), and l is the input\n   -- the integer value a variable is labelled to by the transition.\n   The DFA is deterministic in that there should be at most a single \n   transition for for each unique input and from state. \n</p><p>\n   In addition to the transitions, the DFA requires a unique start\n   state, which is given by Start, and must terminate in one of the final \n   states, which is given in Finals as a collection of values. The\n   Transitions, Start and Finals are mapped onto the data structures\n   for representing a DFA in Gecode. Note however that for Gecode, both\n   the final states and the Transitions must be terminated with a\n   dummy entry (finals with a -1 state, and transitions with a\n   transition with a -1 for the from state), these dummy entries are\n   added by gfd before the constraint is passed to Gecode, so the user\n   should not supply these entries.\n</p><p>\n   The possible values for a sequence of variables can also be specified\n   by regular/2, and using regular expression is probably more\n   convenient. Both constraints map to same underlying implementation.\n   For a sequence of fixed length, the solutions can also be specified\n   using the table/2,3 constraints.\n</p><p>\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_gac for generalised arc consistency (domain consistency).\n</p><p>\n   This constraint is implemented in Gecode as the extensional() constraint \n   with the variant that takes a REG (regular expression) as an argument.\n</p>\n")]).
:- comment(gcc / 2, [amode : gcc(+, +), template : "<ConsistencyModule:> gcc(+Bounds,+Vars)", args : ["Bounds" : "A list of elements specifying the cardinality of values occurring in Vars of the form gcc(Low,High,Value) or occ(Occ,Value).", "Vars" : "A collection of different variables or integers"], summary : "Constrain the cardinality of each Value according to the specification in Bounds.", eg : "[eclipse 2]: gcc([occ{occ:2,value:3},occ{occ:0,value:5},occ{occ:1,value:6}], \n                 [3,3,8,6]).  % fails -- value 8 not specified in Bounds\n\n[eclipse 3]: gcc([occ{occ:2,value:3},occ{occ:0,value:5},occ{occ:1,value:6},\n                 gcc{low:0,high:3,value:8}], [3,3,8,6]).  % succeed\n", kind : [constraint : [extra : [gccat : [global_cardinality, global_cardinality_low_up]]]], see_also : [_60990 : gcc / 2], desc : html("<P>\n    This constraint ensures that the cardinality (the number of occurrences)\n    of values in Vars conforms to the specifications in Bounds. Bounds is a\n    list of specifications in one of the following forms:\n<DL><P>\n <DT><STRONG><TT>gcc(Low,High,Value)</TT></STRONG>\n    <DD>where Value is an integer, a value that Vars is to be assigned to, \n    and must occur only once as a Value in Bounds, and whose cardinality \n    |Value| is specified by Low =&lt; |Value| =&lt; High, where Low and High are \n    non-negative integers.\n <DT><STRONG><TT>occ(Occ,Value)</TT></STRONG>\n    <DD>where Value is an integer, a value that Vars is to be assigned to, \n    and must occur only once as a Value in Bounds, and whose cardinality \n    |Value| is specified by Occ. Occ is either a non-negative integer, or \n    a domain variable whose domain are the possible cardinality for Value.\n    Note that if Occ is a non-gfd domain variable, a type error would\n    be raised. \n</DL></P><P>\n    Note that all values that Vars can take must be specified in Bounds.\n</P><P>\n    ConsistencyModule is the optional module specification to give the \n    consistency level for the propagation for this constraint: \n    gfd_gac for generalised arc consistency (domain consistency), \n    gfd_bc for bounds consistency, and gfd_vc for value consistency.\n</P><P>\n    This constraint is known as global_cardinality (occ{} spec) and\n    global_cardinality_low_up (gcc{} spec) in the Global Constraint\n    Catalog, and is implemented using Gecode's count() constraint (variant \n    with two IntVarArgs and an IntArgs). The semantics is different\n    from that given in the catalog, which does not require all values\n    that Vars can take be specified by Bounds.\n</P>\n")]).
:- comment(get_bounds / 3, [amode : (get_bounds(?, -, -) is det), args : ["Var" : "A variable or a number", "Lo" : "Lower bound", "Hi" : "Upper bound"], summary : "Retrieve the current bounds of Var.", see_also : [get_min / 2, get_max / 2, get_integer_bounds / 3, get_finite_integer_bounds / 3, get_delta / 2, get_median / 2], kind : [varq], desc : html("<P>\n   Primitive for retrieving the upper and lower bounds of Var.  Lo and Hi\n   return the minimum and maximum (respectively) of the variable's interval.\n   If Var has not been declared before, it will be turned into a domain\n   variable with default interval.  If Var is an integer, Lo and Hi will\n   be set to Var.</P>\n")]).
:- comment(get_constraints_number / 2, [amode : (get_constraints_number(?, -) is det), args : ["Var" : "A variable or a term", "Number" : "Variable (instantiates to a non-negative integer)"], summary : "Returns the number of propagators attached to the gecode variable representing Var.", kind : [varq], desc : html("<P>\n   Returns the number of propagators attached to the gecode variable\n   representing Var, This approximates the number of constraints attach\n   to the variables, and is known as the degree of the variable in the\n   literature. \n</P><P>\n   If Var is not a variable, a very large number (1.0Inf) is returned. If\n   Var is a variable but not a domain variable, 0 will be returned.\n</P><P>\n   Note that unlike a native ECLiPSe solver like IC, this is not the number \n   of suspensions on the variable, but is the number of propagators\n   attached to the Gecode variable, obtained via the degree() method\n   for IntVar. Thus, any constraints implemented at the ECLiPSe level\n   will not be included in this count.\n</P>\n")]).
:- comment(get_delta / 2, [amode : (get_delta(?, -) is det), args : ["Var" : "A variable or an integer", "Width" : "Width of the interval"], summary : "Returns the width of the interval of Var.", see_also : [get_median / 2, get_bounds / 3], kind : [varq], desc : html("<P>\n   Returns the width (Hi - Lo) of the interval of Var. If Var is an integer,\n   0 will be returned as the width. If Var is free, then 1.0Inf is\n   returned as the width, but Var is not turned into a domain variable.</P>\n")]).
:- comment(get_domain / 2, [amode : (get_domain(?, -) is det), args : ["Var" : "A GFD domain variable or an integer.", "Domain" : "A ground representation of the domain of Var."], summary : "Returns a ground representation of the current GFD domain of a variable.", see_also : [get_domain_as_list / 2, get_bounds / 3], eg : "\n[eclipse 8]: X :: [1..5,10], get_domain(X, D).\n\nX = X{[1 .. 5, 10]}\nD = [1 .. 5, 10]\n\n", kind : [varq], desc : html("<P>\n   If Var is an integer, Domain will be unified with a singleton list\n   with that integer.</P><P>\n\n   If Var is an GFD domain variable with no holes in its domain, Domain will\n   be unified with the term Lo..Hi where Lo and Hi are integers\n   corresponding to the current lower and upper bounds of Var, respectively.</P><P>\n   If Var is an GFD domain variable with holes in its domain, Domain will\n   be unified with an ordered list of integers and/or terms Lo..Hi where Lo\n   and Hi are integers; in this case the elements of the domain of Var are\n   exactly those integers appearing directly in the list or falling within\n   any of the intervals Lo..Hi.</P>\n"), exceptions : [5 : "Var is neither an IC variable or number."], fail_if : "The initial value of DomainList fails to unify with the returned value."]).
:- comment(get_domain_as_list / 2, [amode : (get_domain_as_list(?, -) is det), args : ["Var" : "A GFD domain variable or a number", "DomainList" : "The domain of Var as a list of elements."], summary : "List of all the elements in the GFD domain of Var", see_also : [get_domain / 2, get_bounds / 3], eg : "\n [eclipse 9]: X :: [1..5,10], get_domain_as_list(X, D).\n\nX = X{[1 .. 5, 10]}\nD = [1, 2, 3, 4, 5, 10]\n\n", kind : [varq], desc : html("<P>\n   If Var is a GFD domain variable, DomainList will be set to an ordered\n   list containing each element in the domain of Var.  If Var is a number,\n   then DomainList will be set to a singleton list containing the number.</P>\n"), exceptions : [5 : "Var is neither a GFD variable or integer."], fail_if : "The initial value of DomainList fails to unify with the returned value."]).
:- comment(get_domain_size / 2, [amode : (get_domain_size(?, -) is det), args : ["Var" : "An GFD domain variable or an integer", "Size" : "A variable (or integer)"], summary : "Size is the number of integer elements in the GFD domain for Var", see_also : [get_delta / 2], kind : [varq], desc : html("<P>\n   If Var is an GFD domain variable, Size will be set to the number of \n   integer values in the domain of Var.  If Var is a number, then Size \n   will be set to 1.</P><P>\n</P>\n"), exceptions : [5 : "Var is neither a GFD variable or integer."], fail_if : "The initial value of Size fails to unify with the returned value."]).
:- comment(get_finite_integer_bounds / 3, [amode : (get_finite_integer_bounds(?, -, -) is det), args : ["Var" : "A variable or a number", "Lo" : "Lower bound", "Hi" : "Upper bound"], summary : "Retrieve the current (finite, integral) bounds of Var.", see_also : [get_bounds / 3, get_integer_bounds / 3], kind : [varq], desc : html("<P>\n   This is provided for compatibility with IC, and is an alias for \n   get_bounds/3.</P>\n")]).
:- comment(get_integer_bounds / 3, [amode : (get_integer_bounds(?, -, -) is det), args : ["Var" : "A variable or an integer", "Lo" : "Lower bound", "Hi" : "Upper bound"], summary : "Retrieve the current bounds of Var.", see_also : [get_bounds / 3, get_finite_integer_bounds / 3], kind : [varq], desc : html("<P>\n   This is provided for compatibility with IC, and is an alias for \n   get_bounds/3.</P>\n")]).
:- comment(get_max / 2, [amode : (get_max(?, -) is det), args : ["Var" : "A variable or an integer", "Hi" : "Upper bound"], summary : "Retrieve the current upper bound of Var.", see_also : [get_bounds / 3, get_integer_bounds / 3, get_finite_integer_bounds / 3], kind : [varq], desc : html("<P>\n   Primitive for retrieving the upper bound of Var.  Hi returns the maximum\n   of the variable's interval. If Var has not been declared before, it\n   will be turned into a domain variable with default interval.</P>\n")]).
:- comment(get_median / 2, [amode : (get_median(?, -) is det), args : ["Var" : "A variable or an integer", "Median" : "The median of the domain"], summary : "Returns the median of the domain of the GFD domain variable Var.", see_also : [get_delta / 2, get_bounds / 3], kind : [varq], desc : html("<P>\n   Returns the median of the domain of Var, i.e. if there are N values in\n   the domain, the N/2'th (rounded down if N is odd) value is returned.\n   Note that this is different from the definition used in IC, where the\n   median (a float) of the interval is returned. If Var is an integer, the \n   median is unified with that number.\n"), eg : "[eclipse 2]: X :: 10..1000, get_median(X, M).\n\nX = X{10 .. 1000}\nM = 500\n\n[eclipse 2]: A :: [2,3,100,1000], get_median(A,M).\n\nA = A{[2, 3, 100, 1000]}\nM = 3\n\n[eclipse 2]: get_median(3, M).\n\nM = 3\n"]).
:- comment(get_min / 2, [amode : (get_min(?, -) is det), args : ["Var" : "A variable or an integer", "Lo" : "Lower bound"], summary : "Retrieve the current lower bound of Var.", see_also : [get_bounds / 3, get_integer_bounds / 3, get_finite_integer_bounds / 3], kind : [varq], desc : html("<P>\n   Primitive for retrieving the lower bound of Var.  Lo returns the minimum\n   of the variable's interval. If Var has not been declared before, it\n   will be turned into a domain variable with default interval.</P>\n")]).
:- comment(get_regret_lwb / 2, [amode : (get_regret_lwb(?, -) is det), args : ["Var" : "A domain variable", "Regret" : "Regret value"], summary : "Returns the regret value for the lower bound of Var.", kind : [varq], desc : html("<P>\n   Returns the regret value for the lower bound of the variable, that is, \n   the magnitude of the difference between the lowest and second lowest value \n   in the variable's domain. This can be used in selecting a variable for \n   labelling.\n</P>\n")]).
:- comment(get_regret_upb / 2, [amode : (get_regret_upb(?, -) is det), args : ["Var" : "A domain variable", "Regret" : "Regret value"], summary : "Returns the regret value for the upper bound of Var.", kind : [varq], desc : html("<P>\n   Returns the regret value for the upper bound of the variable, that is, \n   the magnitude of the difference between the largest and second largest \n   value in the variable's domain. This can be used in selecting a variable \n   for labelling.\n</P>\n")]).
:- comment(get_weighted_degree / 2, [amode : (get_weighted_degree(?, -) is det), args : ["Var" : "A domain variable", "WD" : "Current wighted degree for variable"], summary : "Returns the weighted degree of domain variable Var.", kind : [varq], desc : html("<P>\n   Returns the weighted degree for a domain variable. Weighted degree is call \n   AFC (accumulated failure count) in Gecode, and is a count of the number of \n   failures so far of propagators associated with the variable, plus the \n   number of propagator attached to the variable (to give reasonable \n   starting values when there are not failures yet).  This is usually used \n   in selecting a variable for labelling.\n</P>\n")]).
:- comment(gfd_get_default / 2, [amode : gfd_get_default(+, -), args : ["Parameter" : "GFD parameter (atom).", "DefaultValue" : "Current default value for Parameter."], summary : "Get the current default value for GFD Parameter.", see_also : [gfd_set_default / 2], desc : html("<P>   Get the default value for parameters:\n <UL>\n    <li><b>interval_min</b>\n          Minimum for the default interval for domain variables. \n          Initial value: -1000000.</li>\n    <li><b>interval_max</b>\n          Maximum for the default interval for domain variables. \n          Initial value: 1000000.</li>\n    <li><b>array_size</b>\n          Initial size for the variable array for storing domain variables\n          Initial value: 100.</li>\n    <li><b>cloning_distance</b>\n          This controls how often the gecode state is cloned. The smaller\n          the distance, the more frequent the cloning. Initial value: 2.</li>\n</ul>")]).
:- comment(gfd_handle_tr_out / 2, hidden).
:- comment(gfd_maxint / 1, [amode : gfd_maxint(-), args : ["Var" : "Variable"], summary : "Returns the maximum value allowed in gecode's domain.", see_also : [gfd_minint / 1], desc : html("<P>   Returns the maximum value allowed in gecode's domain. It is strongly\n   recommended that the user values used in the domain to not approach\n   this value, because propagation can easily lead to values outside\n   what gecode can support.")]).
:- comment(gfd_minint / 1, [amode : gfd_minint(-), args : ["Var" : "Variable"], summary : "Returns the minimum value allowed in gecode's domain.", see_also : [gfd_minint / 1], desc : html("<P>   Returns the minimum value allowed in gecode's domain. It is strongly\n   recommended that the user values used in the domain to not approach\n   this value, because propagation can easily lead to values outside\n   what gecode can support.")]).
:- comment(gfd_set_default / 2, [amode : gfd_set_default(+, +), args : ["Parameter" : "GFD parameter to set (atom).", "DefaultValue" : "Default value for Parameter."], summary : "Set the default value for GFD Parameter.", see_also : [gfd_get_default / 2, gfd_minint / 1, gfd_maxint / 1], desc : html("<P>   Set the default value for parameters:\n <UL>\n    <li><b>interval_min</b>\n          Minimum for the default interval for domain variables. When a domain\n          variable is created implicitly in a constraint, it is given a\n          default interval, and this interval should be as small as possible.\n          as the efficiency of various propagator depends on the domain\n          size. (integer no smaller than gfd_minint).</li>\n    <li><b>interval_max</b>\n          Maximum for the default interval for domain variables.\n\t  (integer no larger than gfd_maxint).</li>\n    <li><b>array_size</b>\n          Initial size for the variable array for storing domain variables\n          When more variables than can be accommodated in the array is required,\n          a new array double the size is created, and the old variables copied\n          to the new. Changing the initial size can reduce or avoid this \n          copying overhead. (positive integer).</li>\n    <li><b>cloning_distance</b>\n          This controls how often the gecode state is cloned. The smaller\n          the distance, the more frequent the cloning. Cloning is only done\n          at places where the new clone might be useful, roughly if there are\n          changes to the state since the last clone, and it is possible to \n          backtrack and make use of the new clone (i.e. there should be\n          at least one choice-point between the last clone and the current\n          one. Distance is a measure of such points, so a distance of 1 is \n          the minimal distance where a clone may be needed. (positive \n          integer).</li>\n    <li><b>events_max</b>\n          Maximum number of events during non-search (deterministic) \n          computation before a new clone is created to replace the\n          parent (positive integer).</li>\n</ul>")]).
:- comment(gfd_update / 0, [summary : "Update the parent Gecode space to the current state.", desc : html("<P>\n   This is a low-level primitive that updates (if needed) the parent cloned\n   Gecode space to the current state. The parent clone is from where\n   recomputation is performed, so updating the parent will reduce the\n   amount of recomputation done during subsequent backtracking. Note \n   that the old parent is discarded and replaced by the updated parent\n   if possible.\n</P><P>\n   GFD handles the cloning of Gecode spaces automatically, and the user\n   does not normally have to deal with cloning explicitly. However, if\n   the cloning distance is set very high, so that the system does\n   mostly recomputation instead of copying from clones, it is possible\n   for GFD performance to suffer significantly if the changes to set-up\n   a problem before the search has to be recomputed. This problem does\n   not occur in Gecode when using Gecode's search engine, because the space\n   is always cloned before the start of the search. As the search in\n   ECLiPSe is not normally distinguished from the model setup, GFD\n   cannot automatically ensure that the space is cloned before the\n   start of search (if the search is performed in ECLiPSe). \n</P><P>\n   The update is only done if the current state is different from the \n   parent's, and the current Gecode state is stable (i.e. fully propagated).\n   If the computation since the parent is deterministic, the old\n   parent will be discarded and replaced by the new parent.\n</P><P>\n   The intented use for this predicate is just before the search\n   starts in the user's program, if the search is performed in ECLiPSe. \n   Note that gfd_update is included in GFD's labeling/1 and labeling/3, \n   and so if you use these, you do not need to use gfd_update. Also, this \n   predicate will only be useful if the cloning distance is set very high,\n   and with default settings it should not be needed.\n")]).
:- comment(gfd_var_print / 2, hidden).
:- comment(gfd_vars_exclude / 2, [amode : gfd_vars_exclude(+, ++), args : ["Vars" : "Collection of Domain variable or integer", "Excl" : "Integer value to exclude"], summary : "Exclude the element Excl from the domains of Vars.", kind : [dom], desc : html("<P>\n   Primitive for excluding an element from the domains of variables in Vars.\n</P><P>\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, this predicate does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.</P>\n</P><P>\n   This predicate is specific to lib(gfd), and is more efficient than\n   using multiple exclude/2 for updating each variable in Vars,\n   because this is implementing as one rather than multiple\n   events.\n")]).
:- comment(gfd_vars_exclude_domain / 2, [amode : gfd_vars_exclude_domain(+, ?), amode : gfd_vars_exclude_domain(+, ++), args : ["Vars" : "Collection of variables or integers", "Domain" : "List of domain specs or Domain Variable or integer"], summary : "Exclude the values specified in Domain from the domains of Vars.", kind : [dom], desc : html("\n</P><P>\n   Primitive for excluding the values specified in Domain from the\n   domains of Vars.\n</P><P>\n   Domain can be a list (note only a list is supported in this\n   primitive, and not a collection) of domain specifications, a la the\n   domain specifications of (::)/2 -- i.e. each element can be an\n   integer, or an integer range in the form <pre>Lo..Hi</pre>. Alternatively,\n   Domain can be an existing GFD domain variable, or an integer. \n</P><P>\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, this predicate does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.</P>\n</P><P>\n   This predicate is specific to lib(gfd). For Gecode, if multiple\n   values need to   be excluded from the domain of a variable, it is much more\n   efficient to do it in one go, rather than excluding each value \n   individually (e.g. using gfd_vars_exclude/2). Also, if the values\n   has to be excluded from multiple variables, it is more efficient to use\n   one primitive to do this, rather than exclude the values from each \n   variable individually, as this is done with one event.\n\n")]).
:- comment(gfd_vars_exclude_range / 3, [amode : gfd_vars_exclude_range(+, ++, ++), args : ["Vars" : "Collection of Domain variable or integer", "Lo" : "Integer lower bound of range to exclude", "Hi" : "Integer upper bound of range to exclude"], summary : "Exclude the elements Lo..Hi from the domains of Vars.", kind : [dom], desc : html("<P>\n   Primitive for excluding the integers between Lo and Hi (inclusive) from\n   the domains of variables in Vars. \n</P><P>\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, this predicate does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.</P>\n</P><P>\n   This predicate is specific to lib(gfd), and is more efficient than\n   using multiple exclude_range/2 for updating each variable in Vars,\n   because this is implementing as one rather than multiple\n   events.\n")]).
:- comment(gfd_vars_impose_bounds / 3, [amode : gfd_vars_impose_bounds(+, ++, ++), args : ["Vars" : "Collection of variables or integers", "Lo" : "Lower bound (integer)", "Hi" : "Upper bound (integer)"], summary : "Update (if required) the bounds of Vars.", kind : [dom], desc : html("<P>\n   Primitive for updating the bounds of Vars so that the Lower bounds\n   are at least Lo and the upper bounds are at most Hi.\n   A bound update on a variable may fail (when the update empties\n   the domain), succeed (possibly updating the variable's bounds), or\n   instantiate the variable (in the case where the domain gets restricted to\n   a singleton value).</P><P>\n</P><P>\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, this predicate does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n</P><P>\n   This predicate is specific to lib(gfd), and is more efficient than\n   using multiple impose_max/2 and impose_min/2 for updating each \n   variable in Vars. Also, unlike impose_bounds/2, this primitive does\n   not call wake, so it behaviour is consistent with the other gfd_vars\n   primitives.\n")]).
:- comment(gfd_vars_impose_domain / 2, [amode : gfd_vars_impose_domain(+, ?), amode : gfd_vars_impose_domain(+, ++), args : ["Vars" : "Collection of variables or integers", "Domain" : "List of domain specs or Domain Variable or integer"], summary : "Restrict (if required) the domain of Var to the domain specified  in Domain", see_also : [gfd_vars_impose_min / 2, gfd_vars_impose_max / 2, gfd_vars_impose_bounds / 3, gfd_vars_exclude / 2, gfd_vars_exclude_range / 3, gfd_vars_exclude_domain / 2], kind : [dom], desc : html("<P>\n</P><P>\n   Primitive for restricting the domains of Vars to the domain\n   specified by  Domain. \n</P><P>\n   Domain can be a list (note only a list is supported in this\n   primitive, and not a collection) of domain specifications, a la the\n   domain specifications of (::)/2 -- i.e. each element can be an\n   integer, or an integer range in the form <pre>Lo..Hi</pre>. Alternatively,\n   Domain can be an existing GFD domain variable, or an integer. \n</P><P>\n   The domain update on Vars may fail (when the update empties the\n   domain of any variables in Vars), succeed (possibly updating the \n   variables' domain), or instantiate the variables (in the case where the \n   domain gets restricted to a singleton value).</P><P>\n\n   Note that this predicate is intended for use only in implementing\n   constraint propagators, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, this predicate does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.</P><P>\n\n   This predicate is specific to lib(gfd).\n")]).
:- comment(gfd_vars_impose_max / 2, [amode : gfd_vars_impose_max(+, ++), args : ["Vars" : "Collection of variables or integers", "Bound" : "Upper bound (integer)"], summary : "Update (if required) the upper bounds of Vars.", kind : [dom], desc : html("<P>\n   Primitive for updating the lower bound of Vars so that they are at least\n   Bound.  A bound update on a variable may fail (when the update empties\n   the domain), succeed (possibly updating the variable's bounds), or\n   instantiate the variable (in the case where the domain gets restricted to\n   a singleton value).</P><P>\n</P><P>\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, this predicate does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n</P><P>\n   This predicate is specific to lib(gfd), and is more efficient than\n   using multiple impose_max/2 for updating each variable in Vars,\n   both because this is implementing as one rather than multiple\n   events, and the Gecode rel() constraint for multiple IntVars is\n   used to implement this primitive.\n")]).
:- comment(gfd_vars_impose_min / 2, [amode : gfd_vars_impose_min(+, ++), args : ["Vars" : "Collection of variables or integers", "Bound" : "Lower bound (integer)"], summary : "Update (if required) the lower bounds of Vars.", kind : [dom], desc : html("<P>\n   Primitive for updating the upper bound of Vars so that they are at most\n   Bound.  A bound update on a variable in Vars may fail (when the\n   update empties the domain), succeed (possibly updating the variable's \n   bounds), or instantiate the variable (in the case where the domain gets \n   restricted to a singleton value).</P><P>\n\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, this predicate does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n</P><P>\n   This predicate is specific to lib(gfd), and is more efficient than\n   using multiple impose_min/2 for updating each variable in Vars,\n   both because this is implementing as one rather than multiple\n   events, and the Gecode rel() constraint for multiple IntVars is\n   used to implement this primitive.\n")]).
:- comment(ham_path / 3, [amode : ham_path(?, ?, +), args : ["Start" : "An integer or domain variable", "End" : "An integer or domain variable", "Succ" : "A collection of different variables or integers"], template : "<ConsistencyModule:> ham_path(?Start,?End,+Succ)", summary : "Constrains elements in Succ to form a Hamiltonian path from Start to End.", see_also : [ham_path_g / 3, ham_path_offset_g / 4], kind : [constraint], eg : "[eclipse 5]: ham_path(S,E,[X]).\n\nS = 1\nE = 1\nX = 2\n\n\n[eclipse 2]: ham_path(S,E,[A,B]).\n\nS = S{[1, 2]}\nE = E{[1, 2]}\nA = A{[2, 3]}\nB = B{[1, 3]}\n\n[eclipse 3]: ham_path(2,1,[A,B]).\n\nA = 3\nB = 1\n\n[eclipse 5]: ham_path(S,E,[2,4,1]).\n\nS = 3\nE = 2\n\n", desc : html("<P>  Succ is a collection of N elements presenting a digraph of N nodes, where\n  the i'th element of Succ represents the successor to node i. The constraint\n  enforces Succ to form a Hamiltonian path, a path through every node in\n  the graph, visiting each node once, with Start giving the first node\n  of the path, and End giving the last node of the path. Note that the\n  Succ of the last node will be N+1, i.e. a dummy node not in the graph. \n</P><P>\n  Note that the Gecode implementation of this constraint has index (node id)\n  starting from 0, rather than 1. This constraint is actually posted\n  as ham_path_offset_g/3 with an offset of 1. A version of this constraint\n  with native Gecode indexing is available as circuit_g/1.\n</P><P>\n  ConsistencyModule is the optional module specification to give the \n  consistency level for the propagation for this constraint: \n  gfd_gac for generalised arc consistency (domain consistency), \n  and gfd_vc for value consistency.\n</P><P>\n  This constraint is implemented by Gecode's path() constraint, using an offset \n  of 1.\n</P>\n")]).
:- comment(ham_path / 5, [amode : ham_path(?, ?, +, ++, ?), args : ["Start" : "An integer or domain variable", "End" : "An integer or domain variable", "Succ" : "A collection of N different variables or integers", "CostMatrix" : "A NxN matrix of integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> ham_path(?Start,?End,+Succ,++CostMatrix,?Cost)", summary : "Constrains elements in Succ to form a Hamiltonian path from Start to End with cost Cost.", see_also : [ham_path_offset_g / 6, ham_path / 3, ham_path / 6, ham_path_g / 5], kind : [constraint], eg : "[eclipse 2]: CostM = []([](0,3,5,7),[](4,0,9,6),[](2,1,0,5),[](-7,8,-2,0)),\n        ham_path(4,3,[2,3,5,1], CostM, C).\n\nCostM = []([](0, 3, 5, 7), [](4, 0, 9, 6), [](2, 1, 0, 5), [](-7, 8, -2, 0))\nC = 5\n\n", desc : html("<P>  Succ is a collection of N elements presenting a digraph of N nodes, where\n  the i'th element of Succ represents the successor to node i. The constraint\n  enforces Succ to form a Hamiltonian path, a path through every node in\n  the graph, visiting each node once, with Start giving the first node\n  of the path, and End giving the last node of the path. Note that the\n  Succ of the last node will be N+1, i.e. a dummy node not in the graph. \n  Additionally, CostMatrix specifies the cost for traversing between\n  each pair of nodes: CostMatrix[i,j] represents the cost of\n  travelling from node i to j, and Cost is constrained to the total cost \n  for the path.\n</P><P>\n  Note that the Gecode implementation of this constraint has index (node id)\n  starting from 0, rather than 1. This constraint is actually posted\n  as ham_path_offset_g/4 with an offset of 1. A version of this constraint\n  with native Gecode indexing is available as ham_path_g/3.\n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</P><P>\n  ConsistencyModule is the optional module specification to give the \n  consistency level for the propagation for this constraint: \n  gfd_gac for generalised arc consistency (domain consistency), \n  and gfd_vc for value consistency.\n</P><P>\n  This constraint is implemented by Gecode's path() constraint (variant with \n  cost), using an offset of 1.\n</P>\n")]).
:- comment(ham_path / 6, [amode : ham_path(?, ?, +, ++, +, ?), args : ["Start" : "An integer or domain variable", "End" : "An integer or domain variable", "Succ" : "A collection of N different variables or integers", "CostMatrix" : "A NxN matrix of integers", "ArcCosts" : "A collection of N variables or integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> ham_path(?Start,?End,+Succ,++CostMatrix,+ArcCosts,?Cost)", see_also : [ham_path / 3, ham_path / 5, ham_path_g / 6], summary : "Constrains elements in Succ to form a Hamiltonian path from Start to End with cost Cost.", kind : [constraint], eg : "[eclipse 2]:  CostM = []([](0,3,5,7),[](4,0,9,6),[](2,1,0,5),[](-7,8,-2,0)),\n              ham_path(4,3,[2,3,5,1], CostM, [C1,C2,C3,C4], C).\n\nCostM = []([](0, 3, 5, 7), [](4, 0, 9, 6), [](2, 1, 0, 5), [](-7, 8, -2, 0))\nC1 = 3\nC2 = 9\nC3 = 0\nC4 = -7\nC = 5\n", desc : html("<P>  Succ is a collection of N elements presenting a digraph of N nodes, where\n  the i'th element of Succ represents the successor to node i. The constraint\n  enforces Succ to form a Hamiltonian path, a path through every node in\n  the graph, visiting each node once, with Start giving the first node\n  of the path, and End giving the last node of the path. Note that the\n  Succ of the last node will be N+1, i.e. a dummy node not in the graph. \n  Additionally, CostMatrix specifies the cost for traversing between\n  each pair of nodes: CostMatrix[i,j] represents the cost of\n  travelling from node i to j, and Cost is constrained to the total cost \n  for the path. The i'th element of ArcCosts is constrained to the cost of \n  the arc in the path from node i.\n</P><P>\n  Note that the Gecode implementation of this constraint has index (node id)\n  starting from 0, rather than 1. This constraint is actually posted\n  as ham_path_offset_g/7 with an offset of 1. A version of this constraint\n  with native Gecode indexing is available as ham_path_g/6.\n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</P><P>\n  ConsistencyModule is the optional module specification to give the \n  consistency level for the propagation for this constraint: \n  gfd_gac for generalised arc consistency (domain consistency), \n  and gfd_vc for value consistency.\n</P><P>\n  This constraint is implemented by Gecode's path() constraint (variant with \n  cost and arc costs), using an offset of 1.\n</P>\n")]).
:- comment(ham_path_g / 3, [amode : ham_path_g(?, ?, +), args : ["Start" : "An integer or domain variable", "End" : "An integer or domain variable", "Succ" : "A collection of different variables or integers"], template : "<ConsistencyModule:> ham_path_g(?Start,?End,+Succ)", summary : "Constrains elements in Succ to form a Hamiltonian path from Start to End, with native Gecode indexing.", see_also : [ham_path / 3], kind : [constraint], eg : "[eclipse 6]: ham_path_g(S,E,[A,B]).\n\nS = S{[0, 1]}\nE = E{[0, 1]}\nA = A{[1, 2]}\nB = B{[0, 2]}\n\n[eclipse 7]: ham_path_g(1,0,[A,B]).\n\nA = 2\nB = 0\n\n\n[eclipse 8]: ham_path_g(S,E,[1,3,0]).\n\nS = 2\nE = 1\n\n", desc : html("<P>  This version of ham_path/3 uses the native Gecode indexing, which starts \n  from 0. This is different from normal ECLiPSe's indexing, which starts \n  from 1, and may be incompatible with existing ECLiPSe code. \n</p><p>\n  See ham_path/3 for a more detailed description of this predicate.")]).
:- comment(ham_path_g / 5, [amode : ham_path_g(?, ?, +, ++, ?), args : ["Start" : "An integer or domain variable", "End" : "An integer or domain variable", "Succ" : "A collection of N different variables or integers", "CostMatrix" : "A NxN matrix of integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> ham_path_g(?Start,?End,+Succ,++CostMatrix,?Cost)", summary : "Constrains elements in Succ to form a Hamiltonian path from Start to End with cost Cost. This version uses native Gecode indexing.", see_also : [ham_path / 5], kind : [constraint], eg : "[eclipse 2]: CostM = []([](0,3,5,7),[](4,0,9,6),[](2,1,0,5),[](-7,8,-2,0)),\n        ham_path_g(3,2,[1,2,4,0], CostM, C).\n\nCostM = []([](0, 3, 5, 7), [](4, 0, 9, 6), [](2, 1, 0, 5), [](-7, 8, -2, 0))\nC = 5\n", desc : html("<P>  This version of ham_path/5 uses the native Gecode indexing, which starts \n  from 0. This is different from normal ECLiPSe's indexing, which starts from 1.\n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</p><p>\n  See ham_path/5 for a more detailed description of this predicate.")]).
:- comment(ham_path_g / 6, [amode : ham_path_g(?, ?, +, ++, +, ?), args : ["Start" : "An integer or domain variable", "End" : "An integer or domain variable", "Succ" : "A collection of N different variables or integers", "CostMatrix" : "A NxN matrix of integers", "ArcCosts" : "A collection of N variables or integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> ham_path_g(?Start,?End,+Succ,++CostMatrix,+ArcCosts,?Cost)", summary : "Constrains elements in Succ to form a Hamiltonian path from Start to End, with cost Cost, using native Gecode indexing.", see_also : [ham_path / 6], kind : [constraint], eg : "[eclipse 3]: CostM = []([](0,3,5,7),[](4,0,9,6),[](2,1,0,5),[](-7,8,-2,0)),\n        ham_path_g(3,2,[1,2,4,0], CostM, [C0,C1,C2,C3], C).\n\nCostM = []([](0, 3, 5, 7), [](4, 0, 9, 6), [](2, 1, 0, 5), [](-7, 8, -2, 0))\nC0 = 3\nC1 = 9\nC2 = 0\nC3 = -7\nC = 5\n", desc : html("<P>  This version of ham_path/6 uses the native Gecode indexing, which starts \n  from 0. This is different from normal ECLiPSe's indexing, which starts from 1.\n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</p><p>\n  See ham_path/6 for a more detailed description of this constraint.")]).
:- comment(ham_path_offset / 4, [amode : ham_path_offset(?, ?, +, +), args : ["Start" : "An integer or domain variable", "End" : "An integer or domain variable", "Succ" : "A collection of different variables or integers", "Offset" : "Offset for Succ (An integer)"], template : "<ConsistencyModule:> ham_path_offset(?Start,?End,+Succ,+Offset)", summary : "Constrains elements (offset by Offset) in Succ to form a Hamiltonian path from Start to End.", see_also : [ham_path_offset_g / 4], kind : [constraint], desc : html("<P>  Succ is a collection of N elements presenting a digraph of N nodes, where\n  the i'th element of Succ represents the successor to node i. The constraint\n  enforces (Succ -Offset) to form a Hamiltonian path, a path through\n  every node in the graph, visiting each node once, with Start giving\n  the first node of the path, and End giving the last node of the path.\n  Note that the Succ of the last node will be N+1, i.e. a dummy node\n  not in the graph. \n</P><P>\n  Note that the Gecode implementation of this constraint has index (node id)\n  starting from 0, rather than 1. The value of Offset is incremented by 1 \n  when the constraint is posted to Gecode.  A version of this constraint with\n  native Gecode indexing, i.e. without adjusting Offset, is available \n  as ham_path_offset_g/4.\n</P><P>\n  ConsistencyModule is the optional module specification to give the \n  consistency level for the propagation for this constraint: \n  gfd_gac for generalised arc consistency (domain consistency), \n  and gfd_vc for value consistency.\n</P><P>\n  This constraint is implemented by Gecode's path() constraint, with\n  an actual offset of 1 + Offset.\n</P>\n")]).
:- comment(ham_path_offset / 6, [amode : ham_path_offset(?, ?, +, +, ++, ?), args : ["Start" : "An integer or domain variable", "End" : "An integer or domain variable", "Succ" : "A collection of N different variables or integers", "Offset" : "Offset for Succ (An integer)", "CostMatrix" : "A NxN matrix of integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> ham_path_offset(?Start,?End,+Succ,+Offset,++CostMatrix,?Cost)", summary : "Constrains elements in Succ (offset by Offset) to form a Hamiltonian path from Start to End with cost Cost.", see_also : [ham_path_offset_g / 6, ham_path_offset / 4, ham_path_offset / 7, ham_path / 5], kind : [constraint], desc : html("<P>  Succ is a collection of N elements presenting a digraph of N nodes, where the\n  i'th element of (Succ - Offset) represents the successor to node i.The\n  constraint enforces Succ to form a Hamiltonian path, a path through every\n  node in the graph, visiting each node once, with Start giving the first node\n  of the path, and End giving the last node of the path. Note that the\n  Succ of the last node will be N+1, i.e. a dummy node not in the graph. \n  Additionally, CostMatrix specifies the cost for traversing between\n  each pair of nodes: CostMatrix[i,j] represents the cost of\n  travelling from node i to j, and Cost is constrained to the total cost \n  for the path.\n</P><P>\n  Note that the Gecode implementation of this constraint has index (node id)\n  starting from 0, rather than 1. The value of Offset is incremented by 1 \n  when the constraint is posted to Gecode.  A version of this constraint with\n  native Gecode indexing, i.e. without adjusting Offset, is available \n  as ham_path_offset_g/6.\n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</P><P>\n  ConsistencyModule is the optional module specification to give the \n  consistency level for the propagation for this constraint: \n  gfd_gac for generalised arc consistency (domain consistency), \n  and gfd_vc for value consistency.\n</P><P>\n  This constraint is implemented by Gecode's path() constraint (variant with \n  cost), using an actual offset of Offset + 1.\n</P>\n")]).
:- comment(ham_path_offset / 7, [amode : ham_path_offset(?, ?, +, +, ++, +, ?), args : ["Start" : "An integer or domain variable", "End" : "An integer or domain variable", "Succ" : "A collection of N different variables or integers", "Offset" : "Offset for Succ (An integer)", "CostMatrix" : "A NxN matrix of integers", "ArcCosts" : "A collection of N variables or integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> ham_path_offset(?Start,?End,+Succ,+Offset,++CostMatrix,+ArcCosts,?Cost)", see_also : [ham_path_offset / 4, ham_path_offset / 6, ham_path_offset_g / 7], summary : "Constrains elements in Succ (offset by Offset) to\n form a Hamiltonian path from Start to End with cost Cost.", kind : [constraint], desc : html("<P>  Succ is a collection of N elements presenting a digraph of N nodes, where the\n  i'th element of (Succ - Offset) represents the successor to node i. The\n  constraint enforces Succ to form a Hamiltonian path, a path through every\n  node in the graph, visiting each node once, with Start giving the first node\n  of the path, and End giving the last node of the path. Note that the\n  Succ of the last node will be N+1, i.e. a dummy node not in the graph. \n  Additionally, CostMatrix specifies the cost for traversing between\n  each pair of nodes: CostMatrix[i,j] represents the cost of\n  travelling from node i to j, and Cost is constrained to the total cost \n  for the path. The i'th element of ArcCosts is constrained to the cost of \n  the arc in the path from node i.\n</P><P>\n  Note that the Gecode implementation of this constraint has index (node id)\n  starting from 0, rather than 1. The value of Offset is incremented by 1 \n  when the constraint is posted to Gecode.  A version of this constraint with\n  native Gecode indexing, i.e. without adjusting Offset, is available \n  as ham_path_offset_g/5.\n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</P><P>\n  ConsistencyModule is the optional module specification to give the \n  consistency level for the propagation for this constraint: \n  gfd_gac for generalised arc consistency (domain consistency), \n  and gfd_vc for value consistency.\n</P><P>\n  This constraint is implemented by Gecode's path() constraint (variant with \n  cost and arc costs), using an offset of Offset + 1.\n</P>\n")]).
:- comment(ham_path_offset_g / 4, [amode : ham_path_offset_g(?, ?, +, +), args : ["Start" : "An integer or domain variable", "End" : "An integer or domain variable", "Succ" : "A collection of different variables or integers", "Offset" : "Offset for Succ (An integer)"], template : "<ConsistencyModule:> ham_path_g(?Start,?End,+Succ,+Offset)", summary : "Constrains elements (offset by Offset) in Succ to form a Hamiltonian path from Start to End, with native Gecode indexing.", see_also : [ham_path_offset / 4], kind : [constraint], desc : html("<P>  This version of ham_path_offset/4 uses the native Gecode indexing, which\n  starts from 0. This is different from normal ECLiPSe's indexing, which\n  starts from 1. Offset is not adjusted in this version. This version of \n  the constraint is provided for completeness, in case the user is using\n  native Gecode indexing in their code, so that Offset does not need to\n  be adjusted manually by the user. \n </p><p>\n  See ham_path_offset/4 for a more detailed description of this predicate.")]).
:- comment(ham_path_offset_g / 6, [amode : ham_path_offset_g(?, ?, +, +, ++, ?), args : ["Start" : "An integer or domain variable", "End" : "An integer or domain variable", "Succ" : "A collection of N different variables or integers", "Offset" : "Offset for Succ (An integer)", "CostMatrix" : "A NxN matrix of integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> ham_path_offset_g(?Start,?End,+Succ,+Offset,++CostMatrix,?Cost)", summary : "Constrains elements in Succ (offset by Offset) to\n form a Hamiltonian path from Start to End with cost Cost. This version uses native Gecode indexing.", see_also : [ham_path_offset / 6], kind : [constraint], desc : html("<P>  This version of ham_path_offset/4 uses the native Gecode indexing, which\n  starts from 0. This is different from normal ECLiPSe's indexing, which\n  starts from 1. Offset is not adjusted in this version. This version of \n  the constraint is provided for completeness, in case the user is using\n  native Gecode indexing in their code, so that Offset does not need to\n  be adjusted manually by the user. \n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</p><p>\n  See ham_path_offset/6 for a more detailed description of this predicate.")]).
:- comment(ham_path_offset_g / 7, [amode : ham_path_offset_g(?, ?, +, +, ++, +, ?), args : ["Start" : "An integer or domain variable", "End" : "An integer or domain variable", "Succ" : "A collection of N different variables or integers", "Offset" : "Offset for Succ (An integer)", "CostMatrix" : "A NxN matrix of integers", "ArcCosts" : "A collection of N variables or integers.", "Cost" : "An domain variable or integer."], template : "<ConsistencyModule:> ham_path_offset_g(?Start,?End,+Succ,+Offset,++CostMatrix,+ArcCosts,?Cost)", summary : "Constrains elements in Succ (offset by Offset) to form a Hamiltonian path from Start to End with cost Cost, using native Gecode indexing.", see_also : [ham_path_offset / 7], kind : [constraint], desc : html("<P>  This version of ham_path_offset/7 uses the native Gecode indexing, which starts \n  from 0. This is different from normal ECLiPSe's indexing, which starts from 1.\n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</p><p>\n  See ham_path_offset/7 for a more detailed description of this predicate.")]).
:- comment(impose_bounds / 3, [amode : impose_bounds(?, ++, ++), args : ["Var" : "Variable or integer", "Lo" : "Lower bound (integer)", "Hi" : "Upper bound (integer)"], summary : "Update (if required) the bounds of Var.", see_also : [impose_min / 2, impose_max / 2], kind : [dom], desc : html("<P>\n   This predicate is provided mainly for compatibility with IC solver.\n   If you intend to impose the same bounds on multiple variables, it\n   is more efficient to use the lib(gfd) specific gfd_vars_impose_min/2\n   (which additionally does not call wake).\n</P><P>\n   Primitive for updating the upper and lower bounds of Var, As with \n   impose_min/2 and impose_max/2, it is intended for use in implementing \n   co-operation with other solvers, and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user \n   code (use ::/2 instead).  Its semantics is essentially:\n<PRE>\n       impose_min(Var, Lo), impose_max(Var, Hi), wake.\n</PRE>\n</P>\n")]).
:- comment(impose_domain / 2, [amode : impose_domain(?, ?), args : ["Var" : "Variable or integer", "DomVar" : "Variable or integer"], summary : "Restrict (if required) the domain of Var to the domain of DomVar.", see_also : [impose_min / 2, impose_max / 2, impose_bounds / 3, exclude / 2, exclude_range / 3], kind : [dom], desc : html("<P>\n   This predicate is provided mainly for compatibility with IC solver.\n   If you intend to impose the same domain on multiple variables, it\n   is more efficient to use the lib(gfd) specific gfd_vars_impose_domain/2,\n   which additionally offer more flexibility in allowing the domain to be\n   specified as a list.\n</P><P>\n   Primitive for restricting the domain of Var to the domain of DomVar.\n   Any values in the domain of Var, which are not also in the domain of\n   DomVar, are removed.  DomVar remains unaffected.  \n   The domain update on Var may fail (when the update empties the domain),\n   succeed (possibly updating the variable's domain), or instantiate the\n   variable (in the case where the domain gets restricted to a singleton\n   value).</P><P>\n\n   Note that this predicate is intended for use only in implementing\n   constraint propagators, and should not be called from ordinary user code.\n   The waking behaviour is the same as discussed for impose_min/2 and\n   impose_max/2.  Apart from this, the effect is similar to unifying\n   Var with a copy of DomVar.\n</P>\n"), eg : "    ?- X::1..9, Y::5..7, impose_domain(X, Y).\n    X = X{5 .. 7}\n    Y = Y{5 .. 7}\n\n\n    ?- X::1..9, impose_domain(X, 7).\n    X = 7\n\n\n    ?- X::1..3, Y::5..7, impose_domain(X, Y).\n    No (0.00s cpu)\n\n    ?- Y::1..5, impose_domain(3, Y).\n    Y = Y{1 .. 5}\n\n    ?- Y::1..5, impose_domain(6, Y).\n    No (0.00s cpu)\n\n\n    ?- Y::1..5, impose_domain(X, Y).\n    Y = Y{1 .. 5}\n    X = X{1 .. 5}\n\n"]).
:- comment(impose_max / 2, [amode : impose_max(?, ++), args : ["Var" : "Variable or integer", "Bound" : "Upper bound (integer)"], summary : "Update (if required) the upper bound of Var.", see_also : [impose_min / 2, impose_bounds / 3, impose_domain / 2, exclude / 2, exclude_range / 3], kind : [dom], desc : html("<P>\n   This predicate is provided mainly for compatibility with IC solver.\n   If you intend to impose the same maximum on multiple variables, it\n   is more efficient to use the lib(gfd) specific gfd_vars_impose_max/2.\n</P><P>\n   Primitive for updating the upper bound of Var so that it is at most\n   Bound.  A bound update on a variable may fail (when the update empties\n   the domain), succeed (possibly updating the variable's bounds), or\n   instantiate the variable (in the case where the domain gets restricted to\n   a singleton value).  Note that if the variable's type is integer, its\n   bounds will always be adjusted to integral values.</P><P>\n</P><P>\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, impose_max/2 does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.</P>\n")]).
:- comment(impose_min / 2, [amode : impose_min(?, ++), args : ["Var" : "Variable or integer", "Bound" : "Lower bound (integer)"], summary : "Update (if required) the lower bound of Var.", see_also : [impose_max / 2, impose_bounds / 3, impose_domain / 2, exclude / 2, exclude_range / 3], kind : [dom], desc : html("<P>\n   This predicate is provided mainly for compatibility with IC solver.\n   If you intend to impose the same minimum on multiple variables, it\n   is more efficient to use the lib(gfd) specific gfd_vars_impose_min/2.\n</P><P>\n   Primitive for updating the lower bound of Var so that it is at least\n   Bound.  A bound update on a variable may fail (when the update empties\n   the domain), succeed (possibly updating the variable's bounds), or\n   instantiate the variable (in the case where the domain gets restricted to\n   a singleton value).</P><P>\n</P><P>\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, impose_min/2 does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n</P>\n")]).
:- comment(indomain / 1, [amode : (indomain(?) is nondet), args : ["Var" : "An GFD domain variable or an integer"], kind : [search], summary : "Instantiates a domain GFD variable to an element of its domain.", see_also : [try_value / 2, gfd_search : indomain / 2, labeling / 1, (::) / 2, _10562 : indomain / 1], desc : html("<P>\n   Simple predicate for instantiating a GFD domain variable to an element\n   of its domain.  It starts with the smallest element, and upon\n   backtracking tries successive elements until the entire domain has been\n   explored, at which point the predicate fails.</P><P>\n\n   If Var is already a ground integer, then this predicate simply succeeds\n   exactly once without leaving a choicepoint.</P><P>\n\n   Note that this predicate is an alias for using the indomain_min method\n   of try_value/2.\n</P>\n")]).
:- comment(integers / 1, [amode : (integers(-) is det), amode : (integers(+) is semidet), args : ["Vars" : "Variable or integer, or a collection of variables"], summary : "Vars' domain is the integer numbers (within default bounds).", see_also : [_3245 : integers / 1], kind : [constraint], desc : html("<P>\n   Constrain the variables to integer values.  If any variable is a non-domain\n   variable, a default domain will be created for it.\n")]).
:- comment(inverse / 2, [amode : inverse(+, +), args : ["Succ" : "A collection of N different variables or integers", "Pred" : "A collection  of N different variables or integers"], template : "<ConsistencyModule:> inverse(+Succ,+Pred)", summary : "Constrains elements of Succ to be the successors and Pred to be the predecessors of nodes in a digraph", see_also : [inverse_g / 2, inverse / 2], kind : [constraint : [extra : [gccat : inverse]]], desc : html("<P>\n     Succ and Pred are collections of N elements, representing a digraph of \n     N nodes, where the i'th element of Succ and Pred represents the \n     successor and predecessor of the node i respectively. The constraint \n     enforces each node in the digraph to have one successor and one \n     predecessor node, and that if node y is the successor of node x, then \n     node x is the predecessor of node y.\n</P><P>\n    One of the two arguments can be uninstantiated or partial list\n    at call time.\n</P><P>\n     Note that the Gecode implementation of this constraint actually index\n     from 0. A dummy element is added to the start of Succ and Pred so that\n     the indices returned corresponds to ECLiPSe's (starting from 1). A\n     version of this constraint using native Gecode indexing is available\n     as inverse_g/2.\n</P><P>\n    ConsistencyModule is the optional module specification to give the \n    consistency level for the propagation for this constraint: \n    gfd_gac for generalised arc consistency (domain consistency), \n    and gfd_vc for value consistency.\n</P><P>\n     This constraint is known as inverse in the global constraint catalog,\n     but with implicit node index based on the position in the list, and\n     is implemented using Gecode's channel() constraint (variant with two\n     IntVarArgs).\n</P>\n")]).
:- comment(inverse / 4, [amode : inverse(+, +, +, +), args : ["Succ" : "A collection of N different variables or integers", "SuccOffset" : "An integer.", "Pred" : "A collection  of N different variables or integers", "PredOffset" : "An integer."], template : "<ConsistencyModule:> inverse(+Succ,+SuccOffset,+Pred,+PredOffset)", summary : "Constrains elements of Succ (with SuccOffset) to be the successors and Pred (with PredOffset) to be the predecessors of nodes in a digraph", see_also : [inverse_g / 4], kind : [constraint : [extra : [gccat : inverse_offset]]], desc : html("<P>\n     Succ and Pred are list of N elements, representing a digraph of N nodes,\n     where the i'th element of Succ and Pred represents the successor and\n     predecessor of the node i respectively. The constraint enforces each\n     node in the digraph to have one successor and one predecessor node, and\n     that if the successor of node y minus SuccOffset is equal to x, then\n     the predecessor of node x minus PredOffset is equal to y.\n</P><P>\n    One of the two collection arguments (Succ and Pred) can be uninstantiated \n    or partial list at call time.\n</P><P>\n     Note that the gecode implementation of this constraint actually index\n     from 0. The SuccOfffset and PredOffset are adjusted accordingly before\n     posting to gecode so that the indices returned corresponds to \n     ECLiPSe's (starting from 1).\n</P><P>\n    ConsistencyModule is the optional module specification to give the \n    consistency level for the propagation for this constraint: \n    gfd_gac for generalised arc consistency (domain consistency), \n    and gfd_vc for value consistency.\n</P><P>\n     This constraint is known as inverse_offset in the global constraint \n     catalog, but with implicit node index based on the position in the list.  \n     It is implemented using Gecode's channel() constraint (variant with two\n     IntVarArgs and two integer offsets).\n</P>\n")]).
:- comment(inverse_g / 2, [amode : inverse_g(+, +), args : ["Succ" : "A collection of N different variables or integers", "Pred" : "A collection  of N different variables or integers"], template : "<ConsistencyModule:> inverse_g(+Succ,+Pred)", summary : "Constrains elements of Succ to be the successors and Pred to be the predecessors of nodes in a digraph, using native Gecode indexing.", see_also : [inverse / 2], kind : [constraint : [extra : [gccat : inverse]]], desc : html("  This version of inverse/2 uses the native Gecode indexing, which starts \n  from 0, i.e. the first elements in Succ and Pred has position 0. This is \n  different from normal ECLiPSe's indexing, which starts from 1.\n</p><p>\n  This predicate maps more directly to Gecode's native implementation of \n  the constraint, without the conversion between Gecode and ECLiPSe\n  indexing of inverse/2. It may therefore be more efficient, but could also\n  be incompatible with existing ECLiPSe code. \n</p><p>\n  See inverse/2 for a more detailed description of this predicate.")]).
:- comment(inverse_g / 4, [amode : inverse_g(+, +, +, +), args : ["Succ" : "A collection of N different variables or integers", "SuccOffset" : "An integer.", "Pred" : "A collection  of N different variables or integers", "PredOffset" : "An integer."], template : "<ConsistencyModule:> inverse_g(+Succ,+SuccOffset,+Pred,+PredOffset)", summary : "Constrains elements of Succ (with SuccOffset) to be the successors and Pred (with PredOffset) to be the predecessors of nodes in a digraph", see_also : [inverse / 4], kind : [constraint : [extra : [gccat : inverse_offset]]], desc : html("  This version of inverse/4 uses the native Gecode indexing, which starts \n  from 0, i.e. the first elements in Succ and Pred has position 0. This is \n  different from normal ECLiPSe's indexing, which starts from 1.\n</p><p>\n  This predicate maps directly to Gecode's native implementation of \n  the constraint, without the offset adjustments of inverse/4.\n</p><p>\n  See inverse/4 for a more detailed description of this predicate.")]).
:- comment(is_exact_solver_var / 1, [amode : (is_exact_solver_var(?) is semidet), args : ["Term" : "A Term"], summary : "Succeeds iff Term is an GFD domain variable.", fail_if : "Var is not an GFD domain variable.", kind : [varq], desc : html("<P>\n   Test if the term Term is an GFD domain variable. This is an alias for\n   is_solver_var/1 in GFD.\n")]).
:- comment(is_in_domain / 2, [amode : (is_in_domain(++, ?) is semidet), args : ["Val" : "An integer", "Var" : "A GFD domain variable or an integer"], summary : "Succeeds iff Val is in the domain of Var", exceptions : [5 : "Val is not an integer"], see_also : [is_in_domain / 3], kind : [varq], desc : html("<P>\n   Low level predicate which succeeds when Val is in the domain of Var.\n</P>\n")]).
:- comment(is_in_domain / 3, [amode : (is_in_domain(++, ?, -) is det), args : ["Val" : "A number", "Var" : "A GFD domain variable or an integer", "Result" : "An atom"], summary : "Binds Result to indicate presence of Val in domain of Var", exceptions : [5 : "Val is not an integer"], see_also : [is_in_domain / 2], kind : [varq], desc : html("<P>\n   Low level predicate which succeeds when Val is in the domain of Var with\n   Result bound to the atom 'yes'.  When Val is not in the domain of Var,\n   the predicate succeeds binding Result to the atom 'no'. \n</P>\n")]).
:- comment(is_solver_type / 1, [amode : (is_solver_type(?) is semidet), args : ["Term" : "A Term"], summary : "Succeeds iff Term is a GFD domain variable or an integer.", fail_if : "Var is not a GFD domain variable or an integer.", kind : [varq], desc : html("<P>\n   Test if the term Term is a GFD domain variable or an integer.\n   Succeed if it is, fail otherwise.</P>\n")]).
:- comment(is_solver_var / 1, [amode : (is_solver_var(?) is semidet), args : ["Term" : "A Term"], summary : "Succeeds iff Term is an GFD domain variable.", fail_if : "Var is not an GFD domain variable.", kind : [varq], desc : html("<P>\n   Test if the term Term is an GFD domain variable.  Succeed if it is, fail\n   otherwise.</P>\n")]).
:- comment(labeling / 1, [amode : (labeling(+) is nondet), args : ["Vars" : "A collection (a la collection_to_list/2) of integer IC variables or integers"], summary : "Instantiates all variables in a collection to elements of their domains.", see_also : [gfd_search : indomain / 2, _11413 : labeling / 1, collection_to_list / 2], kind : [search], desc : html("<P>\n   Simple predicate for instantiating a collection of GFD domain variables\n   to elements of their domains.  (Integers are also allowed in the\n   collection; they are effectively ignored.)  The variables are\n   instantiated in the order in which they appear in the collection; the\n   implementation is essentially:\n<PRE>\n\tlabeling(Vars) :-\n\t\tcollection_to_list(Vars, List),\n                gfd_update,\n\t\t( foreach(Var,List) do\n\t\t    indomain(Var,min)\n\t\t).\n</PRE></P>\n   Note that labeling performs the search in ECLiPSe, but it uses\n   indomain/2 with min, which is optimised for use with Gecode, and a \n   gfd_update before the labeling starts to ensure that no recomputation\n   will not be done for events before the labeling starts.\n</P>\n")]).
:- comment(lex_eq / 2, [summary : "Collection1 is lexicographically equal to Collection2", amode : lex_eq(+, +), args : ["Collection1" : "Collection of integers or domain variables", "Collection2" : "Collection of integers or domain variables"], kind : [constraint : [extra : [gccat : lex_equal]]], eg : "\n[eclipse 48]: lex_eq([1,9,1,5], [1,9,1,5]).\n\n...\nYes (0.00s cpu)\n[eclipse 49]: lex_eq([1,9,1,5], [1,9,2,5]).\n\nNo (0.00s cpu)\n[eclipse 50]: lex_eq([1,9,1,5], [1,9,0,5]).\n\nNo (0.00s cpu)\n[eclipse 51]: lex_eq([1,9,1], [1,9,1,5]).\n\nNo (0.00s cpu)\n", see_also : [lex_lt / 2, lex_gt / 2, lex_ge / 2, lex_ne / 2], desc : html("    \tConstrains the two collections to be lexicographically equal, i.e.\n\tthe two collections are the same length, and each\n        element is identical to its corresponding element in the\n        other collection.\n</P><P>\n        This constraint is known as lex_equal in the global constraint\n        catalog, but the catalog's definition requires Collection1 and\n        Collection2 to be the same size. It is implemented using Gecode's\n        rel() constraint (variant that takes two IntVarArgs arguments),\n        with the IRT_EQ IntRelType.\n</P>\n\n")]).
:- comment(lex_ge / 2, [summary : "Collection1 is lexicographically greater or equal to Collection2", amode : lex_ge(+, +), args : ["Collection1" : "Collection of integers or domain variables", "Collection2" : "Collection of integers or domain variables"], kind : [constraint : [extra : [gccat : lex_greatereq]]], eg : "\n[eclipse 40]: lex_ge([5,2,8,9],[5,2,6,2]).\n\n...\nYes (0.00s cpu)\n[eclipse 41]: lex_ge([5,2,3,9], [5,2,3,9]).\n\n...\nYes (0.00s cpu)\n\n[eclipse 42]: lex_ge([5,2,3,9], [5,2,3]).\n\n...\nYes (0.00s cpu)\n[eclipse 43]: lex_ge([5,2,3,9], [5,3,1]).\n\nNo (0.00s cpu)\n", see_also : [lex_lt / 2, lex_gt / 2, lex_eq / 2, lex_ne / 2], desc : html("    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of Collection1 strictly larger\n\tthan the first element of Collection2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n        reached) is strictly smaller than any existing element.\n</P><P>\n        This constraint is known as lex_greatereq in the global constraint\n        catalog, but the catalog's definition requires Collection1 and\n        Collection2 to be the same size. It is implemented using Gecode's\n        rel() constraint (variant that takes two IntVarArgs arguments),\n        with the IRT_GQ IntRelType.\n</P>\n")]).
:- comment(lex_gt / 2, [summary : "Collection1 is lexicographically greater than  Collection2", amode : lex_gt(+, +), args : ["Collection1" : "Collection of integers or domain variables", "Collection2" : "Collection of integers or domain variables"], kind : [constraint : [extra : [gccat : lex_greater]]], eg : "\n[eclipse 44]: lex_gt([5,2,7,1], [5,2,6,2]).\n\n...\nYes (0.00s cpu)\n[eclipse 45]: lex_gt([5,2,7,1], [5,2,7]).\n\n...\nYes (0.00s cpu)\n[eclipse 46]: lex_gt([5,2,7,1], [5,2,7,3]).\n\nNo (0.00s cpu)\n", see_also : [lex_lt / 2, lex_ge / 2, lex_eq / 2, lex_ne / 2], desc : html("    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of Collection1 strictly greater\n\tthan the first element of Collection2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n        reached)is strictly smaller than any existing element.\n</P><P>\n        This constraint is known as lex_greater in the global constraint\n        catalog, but the catalog's definition requires Collection1 and\n        Collection2 to be the same size. It is implemented using Gecode's\n        rel() constraint (variant that takes two IntVarArgs arguments),\n        with the IRT_GR IntRelType.\n</P>\n")]).
:- comment(lex_le / 2, [summary : "Collection1 is lexicographically less or equal to Collection2", amode : lex_le(+, +), args : ["Collection1" : "Collection of integers or domain variables", "Collection2" : "Collection of integers or domain variables"], kind : [constraint : [extra : [gccat : lex_leq]]], eg : "\n[eclipse 31]: lex_le([5,2,3,1], [5,2,6,2]).\n   ...\nYes (0.00s cpu)\n[eclipse 32]: lex_le([5,2,3,9], [5,2,3,9]).\n   ...\nYes (0.00s cpu)\n[eclipse 33]: lex_le([5,2,4], [5,2,4,1]).\n  ...\nYes (0.00s cpu)\n[eclipse 34]: lex_le([5,2,4,1], [5,2,4,0]).\n\nNo (0.00s cpu)\n\n", see_also : [lex_lt / 2, lex_gt / 2, lex_ge / 2, lex_eq / 2, lex_ne / 2, _108200 : lex_le / 2], desc : html("    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of Collection1 strictly smaller\n\tthan the first element of Collection2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n        reached) is strictly smaller than any existing element.\n</P><P>\n        This constraint is known as lex_lesseq in the global constraint\n        catalog, but the catalog's definition requires Collection1 and\n        Collection2 to be the same size. It is implemented using Gecode's\n        rel() constraint (variant that takes two IntVarArgs arguments),\n        with the IRT_LQ IntRelType.\n</P>\n")]).
:- comment(lex_lt / 2, [summary : "Collection1 is lexicographically less than  Collection2", amode : lex_lt(+, +), args : ["Collection1" : "Collection of integers or domain variables", "Collection2" : "Collection of integers or domain variables"], kind : [constraint : [extra : [gccat : lex_less]]], see_also : [lex_le / 2, lex_gt / 2, lex_ge / 2, lex_eq / 2, lex_ne / 2, _109319 : lex_lt / 2], eg : "\n[eclipse 36]: lex_lt([5,2,3,9], [5,2,6,2]).\n\n ...\nYes (0.00s cpu)\n[eclipse 37]: lex_lt([5,2,3,9], [5,2,6]).\n\n ...\nYes (0.00s cpu)\n[eclipse 38]: lex_lt([5,2,3], [5,2,3,9]).\n\n ...\nYes (0.00s cpu)\n[eclipse 39]: lex_lt([5,2,3,4], [5,2,3,4]).\n\nNo (0.00s cpu)\n\n", desc : html("    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of Collection1 strictly smaller\n\tthan the first element of Collection2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n        reached)is strictly smaller than any existing element.\n</P><P>\n        This constraint is known as lex_less in the global constraint\n        catalog. but the catalog's definition requires Collection1 and\n        Collection2 to be the same size. It is implemented using Gecode's\n        rel() constraint (variant that takes two IntVarArgs arguments),\n        with the IRT_LE IntRelType.\n</P>\n\n")]).
:- comment(lex_ne / 2, [summary : "Colloection1 is lexicographically not equal to Collection2", amode : lex_ne(+, +), args : ["Collection1" : "Collection of integers or domain variables", "Collection2" : "Collection of integers or domain variables"], kind : [constraint : [extra : [gccat : lex_different]]], eg : "\n[eclipse 52]: lex_ne([5,2,7,1], [5,3,7,1]).\n\n...\nYes (0.00s cpu)\n[eclipse 53]: lex_ne([5,2,7,1], [5,2,7]).\n\n...\nYes (0.00s cpu)\n[eclipse 54]: lex_ne([5,2,7], [5,2,7,1]).\n\n...\nYes (0.00s cpu)\n[eclipse 55]: lex_ne([5,2,7,1], [5,2,7,1]).\n\nNo (0.00s cpu)\n\n", see_also : [lex_lt / 2, lex_gt / 2, lex_eq / 2, lex_ge / 2], desc : html("    \tConstrains the two collections to be lexicographically different, i.e.\n\tthe two collections are either different lengths, or at least\n        one element in one collection is different from its corresponding\n        element in the other collection.\n</P><P>\n        This constraint is known as lex_different in the global constraint\n        catalog, but the catalog's definition requires Collection1 and\n        Collection2 to be the same size. It is implemented using Gecode's\n        rel() constraint (variant that takes two IntVarArgs arguments),\n        with the IRT_NQ IntRelType.\n</P>\n")]).
:- comment(max / 2, [summary : "Max is the maximum of the values in Collection", template : "<ConsistencyModule:> max(+Collection,?Max)", amode : max(+, ?), args : ["Collection" : "A collection (a la collection_to_list/2) of integers or domain variables", "Max" : "Variable or integer"], kind : [constraint : [extra : [gccat : maximum]]], desc : html("\tMax is the maximum of the values in Collection.</P><P>\n\n        You may find it more convenient to embed <TT>maxlist(Vars)</TT> in a\n        constraint expression.\n        </P><P> \n        ConsistencyModule is the optional module specification to give the \n        consistency level for the propagation for this constraint: \n        gfd_bc for bounds consistency, and gfd_gac for domain (generalised \n        arc) consistency. \n</P><P>\n        This constraint is known as maximum in the global constraint catalog,\n        and is implemented using Gecode's max() constraint.\n</P>\n"), see_also : [min / 2, sum / 2, _23332 : max / 2, collection_to_list / 2]]).
:- comment(mem / 2, [amode : mem(+, ?), template : "<ConsistencyModule:> mem(+Vars,?Member)", args : ["Vars" : "Collection (a la collection_to_list/2) of variables or integers (NOT arbitrary expressions)", "Member" : "Member element of Vars (domain variable or integer)"], summary : "Constrains Member to be the a member element in Vars.", see_also : [mem / 3, collection_to_list / 2], kind : [constraint], eg : "[eclipse 7]: A :: 1..10, B :: 2..20, mem([A,B], M).\n\nA = A{[1 .. 10]}\nB = B{[2 .. 20]}\nM = M{[1 .. 20]}\n\n\n[eclipse 8]: A :: 1..10, B :: 2..20, mem([A,B], M), M #< 5.\n\nA = A{[1 .. 10]}\nB = B{[2 .. 20]}\nM = M{[1 .. 4]}\n\n\n[eclipse 9]: A :: 1..10, B :: 2..20, mem([A,B], M), M #< 2.\n\nA = A{[1 .. 10]}\nB = B{[2 .. 20]}\nM = 1\n\n[eclipse 10]: mem([4,5,5,4,1,5], C).\n\nC = C{[1, 4, 5]}\n\n\n", desc : html("<P>\n   Constrains Member to be a one of the elements in Vars.\n</P><P>\n   Note that this constraint has the same declarative semantics as the\n   standard member/2 predicate, but the order of the arguments are\n   reversed to allow the constraint to be used in constraint\n   expressions.\n </P><P>\n   You may find it more convenient to embed <TT>mem(Vars)</TT> in a\n   constraint expression.\n</P><P>\n   This constraint is implemented by Gecode's member() constraint.\n</P><P>\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n       gfd_gac for domain (generalised arc) consistency.\n</P>\n")]).
:- comment(mem / 3, [amode : mem(+, ?, ?), template : "<ConsistencyModule:> mem(+Vars,?Member,?Bool)", args : ["Vars" : "Collection (a la collection_to_list/2) of variables or integers (NOT arbitrary expressions)", "Member" : "Member element of Vars (domain variable or\n integer)", "Bool" : "Reified truth value (0/1 integer or domain variable)"], summary : "Reflect into Bool the truth of Member being a member element of Vars.", see_also : [mem / 2, collection_to_list / 2], kind : [constraint], eg : "[eclipse 11]: A :: 1..10, B :: 2..20, mem([A,B], M, Bool), M #< 2.\n\nA = A{[1 .. 10]}\nB = B{[2 .. 20]}\nM = M{[-1000000 .. 1]}\nBool = Bool{[0, 1]}\n\n\nDelayed goals:\n        gfd : gfd_do_propagate(gfd_prob(nvars(4)))\nYes (0.00s cpu)\n[eclipse 12]: A :: 1..10, B :: 2..20, mem([A,B], M, Bool), M #< 2, Bool = 1.\n\nA = A{[1 .. 10]}\nB = B{[2 .. 20]}\nM = 1\nBool = 1\n\n[eclipse 13]: A :: 1..10, B :: 2..20, mem([A,B], M, Bool), M #< 2, Bool = 0.\n\nA = A{[1 .. 10]}\nB = B{[2 .. 20]}\nM = M{[-1000000 .. 1]}\nBool = 0\n\n", desc : html("<P>\n   Reified form of the mem/2 constraint, which constrains Member to be\n   one of the elements in Vars.\n</P><P>\n   This constraint is implemented by Gecode's member() constraint \n   (reified version).\n</P><P>\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n       gfd_gac for domain (generalised arc) consistency.\n</P>\n")]).
:- comment(min / 2, [summary : "Min is the minimum of the values in Collection", amode : min(+, ?), template : "<ConsistencyModule:> min(+Collection,?Min)", args : ["Collection" : "A collection (a la collection_to_list/2) of integers or domain variables", "Min" : "Variable or integer"], kind : [constraint : [extra : [gccat : minimum]]], desc : html("    \tMin is the minimum of the values in Collection.</P><P>  \n\n        You may find it more convenient to embed <TT>minlist(Vars)</TT> in a\n        constraint expression.\n        </P><P> \n        ConsistencyModule is the optional module specification to give the \n        consistency level for the propagation for this constraint: \n        gfd_bc for bounds consistency, and gfd_gac for domain (generalised \n        arc) consistency. \n</P><P>\n        This constraint is known as minimum in the global constraint catalog,\n        and is implemented using Gecode's min() constraint.\n</P>\n"), see_also : [max / 2, sum / 2, _24353 : min / 2, collection_to_list / 2]]).
:- comment(msg / 3, [amode : msg(-, -, ?), amode : msg(++, ++, ?), args : ["Var1" : "A variable or number", "Var2" : "A variable or number", "MSG" : "Most specific generalisation (variable)"], summary : "Computes the most specific generalisation of Var1 and Var2 that is expressible with GFD variables.", desc : html("<P>\n   The most specific generalisation of two intervals is computed and\n   returned as MSG.  MSG will be the union of the domains of the two\n   variables, with integers treated as a singleton domain.\n   If either Var1 or Var2 are domain-less, or have values that cannot be\n   expressed as domains, MSG remains unbound.\n</P>")]).
:- comment(neg / 1, [amode : neg(+), template : "<ConsistencyModule:> neg(+Con)", args : ["Con" : "Constraint"], summary : "Constraints Con is negated.", see_also : [neg / 2, or / 2, xor / 2, => / 2, <=> / 2, and / 2, _44543 : neg / 1], kind : [constraint], desc : html("<P>\n   Equivalent to 0 #= (Con)</P>\n   <P>\n   The reified constraint Con is negated.  Con must be a constraint that has\n   a corresponding reified form.<P></P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. \n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P>\n")]).
:- comment(neg / 2, [amode : neg(+, ?), template : "<ConsistencyModule:> neg(+Con,Bool)", args : ["Con" : "Constraint", "Bool" : "Reified truth value of the constraint"], summary : "Bool is the logical negation of the reified truth constraints Con.", see_also : [and / 3, neg / 1, xor / 3, or / 3, => / 3, <=> / 3, _45535 : neg / 2], kind : [constraint], desc : html("<P>\n   Equivalent to B #= (Con), Bool #= 1-B</P>\n   <P>\n   Bool is the logical negation of the reified truth constraint Con.  Con\n   must be a constraint that has a corresponding reified form.<P></P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. \n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P>\n")]).
:- comment(nvalues / 3, [summary : "Constrains N, the number of distinct values assigned to Collection to satisfy the relation N Rel Limit.", amode : nvalues(+, +, ?), args : ["Collection" : "Collection of integers or domain variables.", "RelOp" : "One of the atom: #>, #>=, #<, #=<, #=, #\\=", "Limit" : "Variable or integer"], kind : [constraint : [extra : [gccat : nvalues]]], eg : "[eclipse 21]: nvalues([4,5,5,4,1,5], (#=), N).\n\nN = 3\n\n[eclipse 22]: nvalues([A,B,C,D], (#>), N).\n\nA = A{[-1000000 .. 1000000]}\nB = B{[-1000000 .. 1000000]}\nC = C{[-1000000 .. 1000000]}\nD = D{[-1000000 .. 1000000]}\nN = N{[-1000000 .. 3]}\n\n[eclipse 23]: nvalues([A,B,C,D], (#=), N).\n\nA = A{[-1000000 .. 1000000]}\nB = B{[-1000000 .. 1000000]}\nC = C{[-1000000 .. 1000000]}\nD = D{[-1000000 .. 1000000]}\nN = N{[1 .. 4]}\n\n", desc : html("<P>  Constrains N, the number of distinct values assigned to Collection\n  to satisfy the relation N Rel Limit.\n</P><P>\n  Rel can be one of #&gt;, #&gt;=, #&lt;, #=&lt;, #=, #\\= (or equivalently,\n  &gt;, &gt;=, &lt;, =&lt;, =, \\=).\n</P><P>\n  Any input variables which are not already domain variable will be turned \n  into domain variables with default bounds.\n</P><P>\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n</P><P>\n  This constraint is also known as nvalues in the global constraint catalog. \n  It is implemented by Gecode's nvalue() constraint.\n")]).
:- comment(occurrences / 3, [summary : "The value Value occurs in Vars N times", template : "<ConsistencyModule:> occurrences(++Value,+Vars.?N)", amode : occurrences(++, +, ?), args : ["Value" : "Integer (or domain variable)", "Vars" : "Collection (a la collection_to_list/2) of integers or domain variables", "N" : "Domain variable or integer"], kind : [constraint : [extra : [gccat : exactly]]], eg : "\n[eclipse 11]: occurrences(1,[3,5,1,4,1,3], N).\n\nN = 2\n\n[eclipse 12]: occurrences(6, [], N).\n\nN = 0\n\n[eclipse 15]: [A,B,C] :: [1..10], occurrences(3, [A,B,C], 0). \n\nA = A{[1, 2, 4 .. 10]}\nB = B{[1, 2, 4 .. 10]}\nC = C{[1, 2, 4 .. 10]}\n\n\n[eclipse 16]:  N :: [3, 5], occurrences(3, [3,A,3,5,3], N).\n\nN = 3\nA = A{[-1000000 .. 2, 4 .. 1000000]}  % A cannot be 3\n\n\n[eclipse 17]:  N :: [3, 5], occurrences(3, [3,A,3,5,3,3], N).\n\nN = 5\nA = 3\n\n", desc : html("    \t  The value Value occurs in Vars N times.\n<P>\n          ConsistencyModule is the optional module specification to give the \n          consistency level for the propagation for this constraint: \n          gfd_gac for domain (generalised arc) consistency. Note that if\n          Value is a domain variable, then the propagation is weak, achieving\n          neither domain or bound consistency until Value becomes ground.\n</P><P>\n          This constraint can be embedded in a constraint expression in its\n          functional form (without the last argument).\n </p><p>\n          This constraint is a specialisation of the more general count/4\n          constraint, with the (#=) relation, i.e. the occurrences of Value\n          is equal to N. \n</p><p>\n          This constraint is known as exactly in the global constraint\n          catalog, where N is restricted to an integer; the more general \n          count/4 constraint is also known as count in the global \n          constraint catalog, and the constraint is implemented using \n          Gecode's count() constraint.\n  </p>\n"), see_also : [element / 3, atmost / 3, count / 4, collection_to_list / 2, _48859 : occurrences / 3]]).
:- comment(or / 2, [amode : or(+, +), template : "<ConsistencyModule:> +ConX or +ConY", args : ["ConX" : "Constraint", "ConY" : "Constraint"], summary : "At least one of the constraints ConX or ConY must be true.", see_also : [or / 3, neg / 1, xor / 2, and / 2, => / 2, <=> / 2, _35195 : or / 2], kind : [constraint], desc : html("<P>\n   Equivalent to BX #= (ConX), BY #= (ConY), BX + BY #&gt;= 1</P>\n   <P>\n   The two constraints are reified in such a way that at least one must be\n   true.  ConX and ConY must be constraints that have a corresponding\n   reified form.<P></P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. \n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P>\n")]).
:- comment(or / 3, [amode : or(+, +, ?), template : "<ConsistencyModule:> or(+ConX,+ConY,Bool)", args : ["ConX" : "Constraint", "ConY" : "Constraint", "Bool" : "Reified truth value of the constraint"], summary : "Bool is the reified truth of at least one of the constraints ConX or ConY being true.", see_also : [or / 2, neg / 2, xor / 3, and / 3, => / 3, <=> / 3, _36265 : or / 3], kind : [constraint : [extra : [gccat : or]]], desc : html("<P>\n   Equivalent to BX #= (ConX), BY #= (ConY), Bool #= (BX + BY #&gt;= 1)</P>\n   <P>\n   The two constraints are reified in such a way that Bool reflects the\n   truth of at least one being true.  ConX and ConY must be constraints that\n   have a corresponding reified form.<P></P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. \n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P><P>\n   A more restricted version of this constraint is defined in the \n   global constraint catalog as 'or', in that the reified truth value\n   is the logical disjunction of 0/1 variables rather than constraints.\n</P>\n")]).
:- comment(ordered / 2, [summary : "Constrains Vars to be ordered according to Relation", template : "<ConsistencyModule:> ordered(+Relation,+Vars)", amode : ordered(++, +), args : ["Relation" : "One of the atoms #<, #=<, #>, #>=, #=, #\\=", "Vars" : "Collection of integers or domain variables"], kind : [constraint : [extra : [gccat : [strictly_increasing, increasing, strictly_decreasing, decreasing, all_equal, not_all_equal]]]], eg : "[eclipse 9]: ordered((#<), [1,2,3,4]).\n\nYes (0.00s cpu)\n[eclipse 10]: ordered((#<), [1,2,2,3,4]).\n\nNo (0.00s cpu)\n[eclipse 11]: ordered((#=<), [1,2,3,4]).\n\nYes (0.00s cpu)\n[eclipse 12]: ordered((#=<),  [1,2,2,3,4]).\n\nYes (0.00s cpu)\n[eclipse 13]: ordered((#>), [4,3,2,1]).\n\nYes (0.00s cpu)\n[eclipse 14]: ordered((#>), [4,3,3,2,1]).\n\nNo (0.00s cpu)\n[eclipse 15]: ordered((#>=), [4,3,2,1]).\n\nYes (0.00s cpu)\n\n[eclipse 16]:  ordered((#>=), [4,3,3,2,1]).\n\nYes (0.00s cpu)\n[eclipse 17]: ordered((#=), [2,2,3,3]).\n\nNo (0.00s cpu)\n[eclipse 18]: ordered((#=), [2,2,2,2]).\n\nYes (0.00s cpu)\n[eclipse 19]: ordered((#\\=), [2,2,3,3]).\n\nYes (0.00s cpu)\n[eclipse 20]: ordered((#\\=), [2,2,2,2]).\n\nNo (0.00s cpu)\n[eclipse 21]: ordered((#>), [2]).\n\nYes (0.00s cpu)\n[eclipse 22]: ordered((#\\=), [X]).\n\nNo (0.00s cpu)\n[eclipse 23]: [A,B] :: 3..7, [C,D] :: 4..10, ordered((#=), [A,B,C,D]).\n\nA = A{[4 .. 7]}\nB = B{[4 .. 7]}\nC = C{[4 .. 7]}\nD = D{[4 .. 7]}\n\nYes (0.00s cpu)\n[eclipse 24]:  [A,B] :: 3..7, [C,D] :: 4..10, ordered((#>), [A,B,C,D]).\n\nA = 7\nB = 6\nC = 5\nD = 4\n\n", desc : html("      Constrains the elements in Vars to be ordered according to Relation,\n      which is one of  #&gt;, #&gt;=, #&lt;, #=&lt;, #=, #\\= (or equivalently,\n      &gt;, &gt;=, &lt;, =&lt;, =, \\=). Except for #\\=, the relation must\n      hold between any two adjacent two elements in Vars, for  #\\=, the #\\=\n      must hold for at least one adjacent pair of elements in Vars, i.e.\n      not all elements in Vars are equal.\n</P><P>\n      ConsistencyModule is the optional module specification to give the \n      consistency level for the propagation for this constraint: \n        gfd_gac for generalised arc consistency (domain consistency), \n        gfd_bc for bounds consistency, and\n        gfd_vc for value consistency\n</P><P>\n     This constraint is known as strictly_increasing (#&gt), increasing (#=&gt;), .\n     strictly_decreasing (#&lt;), decreasing (#&lt;=), all_equal (#=), \n     not_all_equal (#\\=) in the Global Constraint Catalog, and is implemented\n     using Gecode's rel() constraint (variant with an IntVarArgs and an \n     IntRelType).\n</P>\n    "), see_also : [lex_le / 2, lex_lt / 2, lex_ge / 2, lex_gt / 2, sorted / 2, _114914 : ordered / 2, collection_to_list / 2]]).
:- comment(precede / 2, [summary : "Constrains each value in Values to precede its succeeding\n value in Collection", amode : precede(++, +), args : ["Values" : "Collection of integers", "Collection" : "Collection of integers or domain variables"], kind : [constraint : [extra : [gccat : int_value_precede_chain]]], eg : "[eclipse 18]: precede([4,0,1], [4,0,6,1,0]).   % succeed\n[eclipse 19]: precede([4,0,1], [4,0,6,1,0]).  % succeed\n[eclipse 20]: precede([4,0,1], [4,1,6,1,0]).   % fail\n\n[eclipse 21]: precede([4,0,1], [A,B,C,D,E]).\n\nA = A{[-1000000 .. -1, 2 .. 1000000]}\nB = B{[-1000000 .. 0, 2 .. 1000000]}\nC = C{[-1000000 .. 1000000]}\nD = D{[-1000000 .. 1000000]}\nE = E{[-1000000 .. 1000000]}\n\n", desc : html("      Constrains the first appearance of every value of the ordered\n      collection of integers in Values to precede the first\n      appearance of the next value in Values in the ordered collection of \n      elements in Collection, i.e. the precede/3 constraint to hold\n      for every adjacent integers in Values.\n</P><P>\n      This constraint is known as int_value_precede_chain in the Global\n      Constraint Catalog, and is implemented using Gecode's precede()\n      constraint (variant with IntArg argument for Values).\n</P>\n    "), see_also : [precede / 3, collection_to_list / 2]]).
:- comment(precede / 3, [summary : "Constrains S to precede T in Collection", amode : precede(+, +, +), args : ["S" : "Integer", "T" : "Integer", "Collection" : "Collection of integers or domain variables"], kind : [constraint : [extra : [gccat : int_value_precede]]], eg : "[eclipse 14]: precede(0,1, [4,0,6,1,0]).  % succeed (0 appears before 1)\n\n[eclipse 15]: precede(0,1, [](4,0,6,1,0)). % succeed (0 appears before 1)\n\n[eclipse 16]: precede(0,1, [A,B,C,D,E]).\n\nA = A{[-1000000 .. 0, 2 .. 1000000]}\nB = B{[-1000000 .. 1000000]}\nC = C{[-1000000 .. 1000000]}\nD = D{[-1000000 .. 1000000]}\nE = E{[-1000000 .. 1000000]}\n\n[eclipse 17]:  precede(0,1, [4,1,6,0,0]).   % fail (1 appears before 0)\n\n", desc : html("      Constrains the first appearance of value S to precede the first\n      appearance of value T in the ordered collection of elements in \n      Collection. S and T do not have to appear in Collection: if only\n      S appears, the constraint will succeed, and if only T appears,\n      the constraint will fail. If neither appears, the constraint will\n      succeed.\n</P><P>\n      This constraint is known as int_value_precede in the Global\n      Constraint Catalog, and is implemented using Gecode's precede()\n      constraint (variant with int arguments for s and t).\n</P>\n    "), see_also : [precede / 2, collection_to_list / 2]]).
:- comment(regular / 2, [template : "<ConsistencyModule:> regular(+Vars, ++RegExp)", summary : "Constrain Vars' solutions to conform to that defined in the regular expression RegExp.", amode : regular(+, ++), args : ["Vars" : "Collection of domain variables or integers,\n or a collection of a collection domain variables or integers.", "RegExp" : "A regular expression"], kind : [constraint], eg : "\n[eclipse 8]: regular([0,0,0,1,1,0,0], *(0) + *(1) + +(0)).  % succeed\n\n[eclipse 9]:  L = [A,B,C,D,E], regular(L,  *(0) + *(1) + +(0)), \n               labeling(L), writeln(L), fail.\n[0, 0, 0, 0, 0]\n[0, 0, 0, 1, 0]\n[0, 0, 1, 0, 0]\n[0, 0, 1, 1, 0]\n[0, 1, 0, 0, 0]\n[0, 1, 1, 0, 0]\n[0, 1, 1, 1, 0]\n[1, 0, 0, 0, 0]\n[1, 1, 0, 0, 0]\n[1, 1, 1, 0, 0]\n[1, 1, 1, 1, 0]\n\nNo (0.00s cpu)\n\n[eclipse 10]: regular([A,B,C,D,E,F], ([1, 3, 5], {1, 2}) + *(4))\n\nA = A{[1, 3, 5]}\nB = B{[1, 3 .. 5]}\nC = 4\nD = 4\nE = 4\nF = 4\n\n", see_also : [extensional / 4, table / 2, table / 3], desc : html("   regular is a user defined constraint, i.e. the solutions for the\n   each posted constraint is defined within the constraint. For regular, \n   the regular expression in RegExp defines the sequence of values that \n   the variables for the constraint can take. \n</p><p>\n   Vars represents the variables that are to be satisfied for this\n   constraint. It can be one collection of variables (or integers),\n   or a collection of a collections of variables (or integers), if\n   the constraint is to be satisfied by more than one collection of \n   variables. Each collection can be of different size, i.e. have\n   different number of variables. Posting the constraint with multiple \n   collections of variables is logically equivalent to posting individual \n   constraint with the same RegExp for each collection, but should be\n   more efficient as the same RegExp is shared by all the collections.\n</p><p>\n   RegExp is a regular expression that defines the allowable sequence of\n   values that can be taken by the variables. The syntax is as follows:\n   <DL>\n   <DT><STRONG>N</STRONG><DD>\n\t    N is the integer value taken by a variable.\n   <DT><STRONG>+(RegExp)</STRONG><DD>\n\t    RegExpr is repeated 1 or more times\n   <DT><STRONG>*(RegExp)</STRONG><DD>\n\t    RegExpr is repeated 0 or more times\n   <DT><STRONG>RegExp1 + RegExp2</STRONG><DD>\n\t    RegExp1 is followed by RegExp2\n   <DT><STRONG>(RegExp1 | RegExp2)</STRONG><DD>\n\t    RegExp1 and RegExp2 are alternatives\n   <DT><STRONG>(RegExp,  {N,M})</STRONG><DD>\n            RegExp is repeated at least N times, and at most M times.\n            (N, M are non-negative integers)\n   <DT><STRONG>(RegExp,  {N})</STRONG><DD>\n            RegExp is repeated at least N times (N is a non-negative integer)\n   <DT><STRONG>ValueCollection</STRONG><DD>\n            ValueCollection is a collection of integer values. Each value\n            is a value that the variable is allowed to take in this position.\n   </DL>\n</p><p>\n   Regular expression uses existing standard ECLiPSe operators and\n   functors, so the syntax is slightly different from the standard\n   syntax, and it maps to the regular expression used by Gecode\n   for this constraint. For example, the following\n<pre>\n        RegExp = +(0) + (1, {3,3})\n</pre>\n  specifies a sequence of 1 or more 0s followed by 3 1s. e.g. [0,0,1,1,1].\n</p><p>\n   The possible values for a sequence of variables can also be specified\n   by extensional/4, but using regular expression is probably more\n   convenient, both constraints map to same underlying implementation.\n   For a sequence of fixed length, the solutions can also be specified\n   using the table/2,3 constraints.\n </p><p>\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_gac for generalised arc consistency (domain consistency).\n</p><p>\n   This constraint is implemented in Gecode as the extensional() constraint \n   with the variant that takes a REG (regular expression) as an argument.\n</p>\n")]).
:- comment(scalar_product / 4, [summary : "Constrains the scalar product of the elements of Coeffs and Collection to satisfy the relation sum(Coeffs*Collection) Rel P.", template : "<ConsistencyModule:> scalar_product(++Coeffs,+Collection,+Rel,?Sum)", amode : scalar_product(++, +, +, ?), args : ["Coeffs" : "Collection of N integers.", "Collection" : "Collection of N integers or domain variables.", "RelOp" : "One of the atom: #>, #>=, #<, #=<, #=, #\\=", "P" : "Variable or integer"], kind : [constraint : [extra : [gccat : scalar_product]]], desc : html("<P>          Constrains the scalar product of the elements in Collection to satisfy\n          the relation sum(Coeffs*Collection) Rel P.\n\t  </P><P>\n          Rel can be one of #&gt;, #&gt;=, #&lt;, #=&lt;, #=, #\\= (or equivalently,\n          &gt;, &gt;=, &lt;, =&lt;, =, \\=).\n\t  </P><P>\n          The Scalar Product of the collection of N integers in Coeffs and\n          the collection of N domain variables or integers in Collection \n          is the sum of all Ci*Vi, where Ci is a element in Coeffs and\n          Vi the corresponding element in Collection.\n          </P><P>\n\t  Any input variables which are not already domain variable will be\n          turn into domain variables with default bounds.\n\t  </P><P>\n          You may find it more convenient to embed <TT>scalar_product</TT> in a\n          constraint expression.\n\t  </P><P>\n          ConsistencyModule is the optional module specification to give the \n          consistency level for the propagation for this constraint: \n          gfd_bc for bounds consistency, and \n          gfd_gac for domain (generalised arc) consistency.\n          </P><P>\n          Domain consistency is different from bounds consistency only if\n          Rel is #=.\n          </P><P>\n          This constraint is known as scalar_product in the global constraint \n          catalog, and is implemented using Gecode's linear() constraint.\n          </P>\n    ")]).
:- comment(scalar_product / 5, [summary : "Reflect into Bool the truth of the scalar product of the elements of Coeffs and Collection satisfying the relation  sum(Coeffs*Collection) Rel Sum.", template : "<ConsistencyModule:> scalar_product(++Coeffs,+Collection,+Rel,?Sum,?Bool)", amode : scalar_product(++, +, +, ?, ?), args : ["Coeffs" : "Collection of N integers.", "Collection" : "Collection of N integers or domain variables.", "RelOp" : "One of the atom: #>, #>=, #<, #=<, #=, #\\=", "P" : "Variable or integer", "Bool" : "Variable or the integer 0 or 1"], kind : [constraint], desc : html("<P>          This is the reified form of scalar_product/4, which constrains the\n          scalar product of  the elements in Coeffs and Collection to satisfy\n          the relation \n          sum(Coeffs*Collection) Rel P.\n\t  </P><P>\n          Rel can be one of #&gt;, #&gt;=, #&lt;, #=&lt;, #=, #\\= (or equivalently,\n          &gt;, &gt;=, &lt;, =&lt;, =, \\=).\n          </P><P>\n\t  Any input variables which are not already domain variable will be\n          turn into domain variables with default bounds.</P><P>\n\t  </P><P>\n          ConsistencyModule is the optional module specification to give the \n          consistency level for the propagation for this constraint: \n          gfd_bc for bounds consistency \n          </P><P>\n          This constraint is implemented using Gecode's linear() constraint\n          (reified version).\n          </P>\n    ")]).
:- comment(search / 6, [summary : "Interface to gecode search-engines to perform search in gecode.", amode : (search(+, ++, ++, +, ++, +) is nondet), args : ["L" : "is a collection (a la collection_to_list/2) of domain\n\t    variables (Arg = 0) or a collection of terms (Arg > 0)", "Arg" : "is an integer, which is 0 if L is a collection of\n\t    domain variables or greater than 0 if L consists of terms of\n\t    arity greater than Arg, the value Arg indicates the\n\t    selected argument of the term", "Select" : "is a predefined variable selection method. Predefined methods are \n            input_order, first_fail, anti_first_fail, smallest, largest, \n            occurrence, anti_occurrence, most_constrained, \n            most_constrained_per_value, least_constrained_per_value, \n            max_regret, max_regret_lwb, min_regret_lwb, max_regret_upb,\n            min_regret_upb, random, max_weighted_degree, min_weighted_degree, \n            max_weighted_degree_per_value, min_weighted_degree_per_value", "Choice" : "is the name of a predefine value choice method for choosing\n            the value to try for a variable; Predefined choice methods are:\n            indomain, indomain_reverse_enum, indomain_min, indomain_max, \n            indomain_middle, indomain_median, indomain_split, \n            indomain_reverse_split, indomain_random, indomain_interval,\n            indomain_interval_min, indomain_interval_max", "Method" : "is one of the following:  complete,\n            bb_min(Cost:domain variable),\n\t    restart_min(Cost:domain variable)", "Option" : "is a list of option terms.  Currently recognized are:\n\t  tiebreak(+Select), stats(+Stats), limits(+Stop), \n          timeout(+Seconds), control(+Control), backtrack(-N), \n          node(+Call), nodes(+N)"], kind : [search], desc : html("<b>Search/6</b> provides an interface to gecode's search-engine,\nto allow search to be performed by gecode. It is designed to have the same \narguments as the generic search/6 routine available for integer domain solvers.\nso that for common cases, the call will work for both search/6. The generic\nsearch/6 is available in the gfd_search module. The difference is that here\nthe search is performed by gecode, and is an atomic step when viewed from\nECLiPSe. For the non-optimising search method, backtracking into this\npredicate will produce the next solution if it exists. By changing the \n<b>Method</b> argument, different gecode search-engines (implementation \nof different complete, partial and optimising search algorithms (and \ntheir parameters)) can be selected and controlled. The availability of \noptimising search-engines means that this predicate also provide some of \nthe functionality of lib(branch_and_bound). The predicate also provides a \nnumber of pre-defined variable selection  methods (to choose which variable \nwill be assigned next) and some pre-defined value assignment methods \n(to try out the possible values for the selected variable in some \nheuristic order).\n</P><P>\nIn order to allow more structure in the application program, it is possible \nto pass a collection of terms rather than only a collection of domain \nvariables. In this way all information about some entity can be easily \ngrouped together. \n<p>\nThe variable selection and value choice methods are defined by gecode. They\nare mapped to the closest matching methods in the generic search/6 (or with\na name following the same convention if the method have no correspondence).\nFor variable selection, if several entries\nhave the same heuristic value, then a tiebreak selection method, specified by\nthe tiebreak method, can be used to chose from these entries. Note that\nthere are some differences from ECLiPSe search in how the methods are \napplied: variable selection is always performed before each value selection:\nin ECLiPSe, once a variable is selected, all the possible values for that\nvariable are tried on backtracking without re-selecting the variable. \n<p>\nThe pre-defined <b>selection methods</b> (with the gecode name in brackets) \nuse the following criteria:\n<ul>\n<li><b>input_order</b> (INT_VAR_NONE) the first entry in the list is selected</li>\n<li><b>random</b> (INT_VAR_RND) an entry is selected at random.</li>\n\n<li><b>anti_occurrence</b> (INT_VAR_DEGREE_MIN) the entry whose corresponding gecode variable with the\nsmallest number of attached propagators is selected</li>\n\n<li><b>occurrence</b> (INT_VAR_DEGREE_MAX) the entry whose corresponding gecode variable with the\nlargest number of attached propagators is selected</li>\n\n<li><b>min_weighted_degree</b> (INT_VAR_AFC_MIN) the entry with the smallest\nweighted degree is selected.</li>\n\n<li><b>max_weighted_degree</b> (INT_VAR_AFC_MAX) the entry with the largest\nweighted degree is selected. Weighted degree is call AFC (accumulated failure\ncount) in gecode, and is a count of the number of failures so far of\npropagators associated with the variable, plus the number of propagator\nattached to the variable (to give reasonable starting values when there are\nnot failures yet).</li>\n\n<li><b>smallest</b> (INT_VAR_MIN_MIN) the entry with the smallest value in the domain is selected</li>\n\n<li><b>smallest_upb</b> (INT_VAR_MIN_MAX) the entry with the smallest\n upper bound in the domain is selected</li>\n\n<li><b>largest_lwb</b> (INT_VAR_MAX_MIN) the entry with the largest lower\n  bound in the domain is selected</li>\n\n<li><b>largest</b> (INT_VAR_MAX_MAX) the entry with the largest value in the domain is selected</li>\n\n<li><b>first_fail</b> (INT_VAR_SIZE_MIN) the entry with the smallest domain size is selected</li>\n\n<li><b>anti_first_fail</b> (INT_VAR_SIZE_MAX) the entry with the largest domain size is selected</li>\n\n<li><b>least_constrained_per_value</b> (INT_VAR_SIZE_DEGREE_MIN) the entry with the largest domain size\ndivided by the number of attached propagators.</li> \n\n<li><b>most_constrained_per_value</b> (INT_VAR_SIZE_DEGREE_MAX) the entry with the smallest domain size\ndivided by the number of attached propagators.</li> \n\n<li><b>min_weighted_degree_per_value</b> (INT_VAR_SIZE_AFC_MIN) the entry with\n the smallest domain size divided by weighted degree is selected.</li> \n\n<li><b>max_weighted_degree_per_value</b> (INT_VAR_SIZE_AFC_MAX) the entry with\n the largest domain size divided by weighted degree is selected.</li> \n\n<li><b>min_regret_lwb</b> (INT_VAR_REGRET_MIN_MIN) the entry with the smallest difference between the\nsmallest and second smallest value in the domain is selected.</li>\n\n<li><b>max_regret</b> (INT_VAR_REGRET_MIN_MAX) the entry with the largest difference between the\nsmallest and second smallest value in the domain is selected. This method is\ntypically used if the variable represents a cost, and we are interested in the\nchoice which could increase overall cost the most if the best possibility is\nnot taken. Unfortunately, the implementation sometimes does not always\nwork. If two decision variables incur the same minimal cost, the regret is not\ncalculated as zero, but as the difference from this minimal value to the next\ngreater value. Note this is an alias for max_regret_lwb</li>\n\n<li><b>max_regret_lwb</b> (INT_VAR_REGRET_MIN_MAX) is an alias to max_regret.</li>\n\n<li><b>min_regret_upb</b> (INT_VAR_REGRET_MAX_MIN) the entry with the smallest difference between the\nlargest and second largest value in the domain is selected.</li>\n\n<li><b>max_regret_upb</b> (INT_VAR_REGRET_MAX_MAX) the entry with the largest difference between the\nlargest and second largest value in the domain is selected.</li>\n\n<li><b>most_constrained</b> (INT_VAR_SIZE_MIN, INT_VAR_DEGREE_MAX) the entry with the smallest domain size is\n selected. If several entries have the same domain size, the entry with the\n largest number of attached constraints is selected. This is provided for\n compatibility, as this define a tiebreak method (occurrence). Any tiebreak\n method defined in options is ignored.</li>\n\n</ul><p>\nThe pre-defined <b>choice methods</b> (with gecode name in brackets) have the following meaning:\n<ul>\n<li><b>indomain</b> (INT_VALUES_MIN)\nValues are tried in increasing order. \nOn failure, the previously tested value is not removed.</li>\n\n<li><b>indomain_reverse_enum</b> (INT_VALUES_MAX)\nValues are tried in decreasing order. \nOn failure, the previously tested value is not removed.</li>\n\n<li><b>indomain_min</b> (INT_VAL_MIN)\nValues are tried in increasing order.  On failure, the previously\ntested value is removed.  The values are tested in the same order as\nfor <b>indomain</b>, but backtracking may occur earlier.</li>\n\n<li><b>indomain_max</b> (INT_VAL_MAX)\nValues are tried in decreasing order.  On failure, the previously\ntested value is removed.</li>\n\n<li><b>indomain_median</b>(INT_VAL_MED)\nValues are tried beginning from the median value of the domain.  On\nfailure, the previously tested value is removed, and the new median value will\nbe chosen next.</li>\n\n<li><b>indomain_split</b> (INT_VAL_SPLIT_MIN)\nValues are tried by successive domain splitting, trying the lower half\nof the domain first.  On failure, the tried interval is removed.  This\nenumerates values in the same order as indomain or indomain_min, but\nmay fail earlier.</li>\n\n<li><b>indomain_reverse_split</b> (INT_VAL_SPLIT_MAX)\nValues are tried by successive domain splitting, trying the upper half\nof the domain first.  On failure, the tried interval is removed.  This\nenumerates values in the same order as indomain or indomain_max, but\nmay fail earlier.</li>\n\n<li><b>indomain_random</b> (INT_VAL_RND)\nValues are tried in a random order.  On backtracking, the previously\ntried value is removed.  Using this routine may lead to unreproducible\nresults, as another call will create random numbers in a different\nsequence. </li> \n\n<li><b>indomain_interval</b> (INT_VAL_RANGE_MIN)\nIf the domain consists of several intervals, we first branch on the choice of\nthe interval, choosing the smallest interval.  For one interval, we use domain\nsplitting.</li>\n\n<li><b>indomain_interval_min</b> (INT_VAL_RANGE_MIN)\nAlias for indomain interval.</li>\n\n<li><b>indomain_interval_max</b> (INT_VAL_RANGE_MAX)\nIf the domain consists of several intervals, we first branch on the choice of\nthe interval, choosing the largest interval.  For one interval, we use reverse \ndomain splitting.</li>\n\n</ul><p>\n\n<p>\nThe different <b>search methods</b> are\n<ul>\n<li><b>complete</b> (DFS)\na complete search routine which explores all alternative choices.</li>\n\n\n<li><b>bb_min(Cost)</b> (BAB)\nBranch-and-bound search to find the minimal value for the cost variable Cost.\nThis should be a domain variable that is instantiated at the end of the\nsearch. The search will return an optimal solution, unless terminated early,\nin which case, the best solution found (if there is one) is returned. If Cost\nvariable is not instantiated at the end of the search, the search is aborted.\nThis provide some of the functionality of branch-and-bound search in\nlib(branch_and_bound), but is less flexible (no user defined search) but is \nlikely to be faster.\n\n<li><b>restart_min(Cost)</b> (Restart)\nBranch-and-bound search as in bb_min, but the search is restarted after finding\na new solution and imposing the new bound.        \n\n</ul>\nThe option list is used to pass additional parameters to and from the\nprocedure.  The currently recognized options are:\n<ul>\n<li><b>tiebreak(+Selection)</b>\nSelection is one of the variable selection methods, and is used as a tie-break\nif the primary selection method yields more than one candidate. Obviously not\nall combinations of selection methods makes sense (e.g. it should not be the \nsame as the primary), but no check is done, they are simply passed to gecode.</li>\n <li><b>stats(+Stats)</b>\nStats is a named gfd_stats structure, defined as:\n<pre>\n:- export struct(gfd_stats(prop,fail,node,depth,mem)).\n</pre>\nThe fields of the structure should be uninstantiated, and the search predicate\nwill instantiate the fields with statistics obtained from gecode for the search:\nprop for the number of propagations, fail for the number of failed nodes,\nnode for number of nodes expanded, depth for maximum depth of search stack,\nmem for peak memory allocated (in bytes).</li>\n<li><b>timeout(+Seconds)</b>\nSpecify the number of seconds that the search will be performed before it is\nterminated. Seconds can be a real or integer number, and 0 means there is\nno timeout. The timer is reset each time a new solution is obtained (for the\nnon-optimising search).\n\n<li><b>limits(+Stats)</b>\nSpecify limits to stop the search. Stats is the same gfd_stats struct used for\nobtaining statistics. To specify a limit for a particular statistics, the\ncorresponding field should be instantiated to the limit. Only the prop, node, \nfail and mem fields are significant. Entries in the other fields are ignored.</li>\n\n<li><b>control(+Control)</b>\n Control is a named gfd_control structure, defined as:\n <pre>\n :- export struct(gfd_control(commit_distance,adaptive_distance,threads)).\n</pre>\nThis is used to pass information to gecode to control the search. The\n corresponding field should be instantiated to the value passed to gecode. \n threads may be of most interest as if threads is set to a value &gt;= 2,\n this will allow parallel search. See the gecode manual for more\n details on the options.</li>\n <li><b>backtrack(-N)</b>\nProvided for compatibility with generic search/6. Returns the number of fail\n nodes (fail field of statistics.</li> \n\n<li><b>nodes(++N)</b>\nProvided for compatibility with generic search/6. Equivalent to setting the\nnode field of limits. The node field will be unified with N</li>\n\n</ul>\n"), fail_if : "Fails if the search engine does not find any solution.\nFor partial search methods, this does not mean that the problem does not \nhave a solution.", resat : 'yes (non-optimising searches)', eg : "\ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,complete,[]).\n\ntop:-\n        length(L,8),\n        L::1..8,\n        L = [Cost|L],\n        search(L,0,input_order,indomain_max,bb_min(Cost),[]).\n", see_also : [indomain / 1, gfd_search : indomain / 2, labeling / 1, gfd_search : delete / 5, gfd_search : search / 6]]).
:- comment(select_var / 5, [summary : "Pick a domain variable from a collection according to selection criterion.", amode : (select_var(-, +, +, +, ?) is semidet), args : ["X" : " a free variable", "Vars" : " a collection of GFD domain variables or terms, or a handle ", "Rest" : "variable, will be bound to handle for remaining collection", "Arg" : " an integer", "Select" : "a predefined selection method."], kind : [search], desc : html("<p>\nThis predicate picks one domain variable in Vars based\non some selection criterion. The selected entry is returned in X.\nVars is either a collection of domain variables (Arg is 0), or terms\ncontaining domain variables (in which case the domain variable is in the\n Arg'th argument of each term). \n</p><p>\nThis predicate provides similar functionality as delete/5, but is\nmore efficient and specific to GFD, and Select cannot be a user-\ndefined method. This predicate is more efficient than delete/5\nbecause the variable selection is done by a single low-level\n procedure. Unlike delete/5, which does the selection at the ECLiPSe \nlevel, and deletes the selected element from Vars, select_var/5 can\nselect the variable using a handle, which is a low-level representation\nof the variables extracted from Vars.\nThe first time the\n predicate is called, select_var/5 will extract the domain variables from Vars\nand create the low-level handle to these variables, which is returned in Rest.\nThe handle can then be used (in place of Vars) in subsequent calls to\nselect_var/5, avoiding the overhead of re-analysing the variable collection.\n</p><p>\nSelect is one of the following predefined selection methods:\ninput_order, occurrence, anti_occurrence, \nmax_weighted_degree, min_weighted_degree,\nmax_weighted_degree_per_value, min_weighted_degree_per_value,\nsmallest, largest, smallest_upb, largest_lwb,\nfirst_fail, anti_first_fail, \nmost_constrained,  most_constrained_per_value, least_constrained_per_value, \nmax_regret, max_regret_lwb, min_regret_lwb, max_regret_upb.\n</p><p>\nThese are essentially the same selection methods as those for search/6.\n The selection works by calculating the selection\n criterion for each variable in Vars, in the order they are in\n Vars, and chosing the first variable with the best value. Note\n that only non-instantiated variables (i.e. variable with more than 1\n value in its domain) are considered. If all variables are\n instantiated, the predicate fails, i.e. the predicate will fail when\nall variables in Vars have been labelled. \n </p>\n"), eg : "\n% Simple labelling implemented using select_var/5 and indomain/2\nlabelling1(Vars, Select, Choice) :-\n        (select_var(V, Vars, Rest, 0, Select) ->\n            indomain(V, Choice),\n            labelling1(Rest, Select, Choice)\n        ;\n            true\n        ).\n\n% Variant using select_var/5 and try_value/2\nlabelling2(Vars, Select, Choice) :-\n        (select_var(V, Vars, Rest, 0, Select) ->\n            try_value(V, Choice),\n            labelling2(Rest, Select, Choice)\n        ;\n            true\n        ).\n", fail_if : "fails if no variable can be selected", see_also : [try_value / 2, gfd_search : indomain / 2, search / 6, gfd_search : search / 6]]).
:- comment(sequence / 4, [amode : sequence(+, +, +, +), template : "<ConsistencyModule:> sequence(+Low,+High,+K,+ZeroOnes)", args : ["Low" : "Non-negative integer", "High" : "Positive integer", "K" : "Positive integer", "ZeroOnes" : "A collection of 0/1 variables or integers"], summary : "The number of occurrences of the value 1 is between Low and High for all sequences of K variables in ZeroOnes", see_also : [sequence / 5, _103568 : sequence / 4], kind : [constraint : [extra : [gccat : among_seq]]], eg : "\n[eclipse 20]: sequence(2,3,3,[1,0,1,1,0,1]).    % Succeed\n\n[eclipse 21]: sequence(2,3,3,[1,0,1,1,0,0,1]).  % Fail\n\n", desc : html("<P>\n    This constraint ensures that the number of occurrences of the value 1\n    is at least Low and at most High for all sequences of K consecutive \n    variables/values in ZeroOnes. ZeroOnes are 0/1 variables (or integers), \n    i.e. they have the domain [0,1]. \n</P><P>\n    The ZeroOnes can be interpreted as the fulfillment of various\n    conditions if the variables are linked to these conditions. \n</P><P>\n    ConsistencyModule is the optional module specification to give the \n    consistency level for the propagation for this constraint: \n    gfd_gac for generalised arc consistency (domain consistency), \n</P><P>\n    The more general version of this constraint, sequence/5, where the \n    values being checked is not limited to 1 is known as among_seq in the \n    global constraint catalog, and this constraint is also implemented\n    via the more general Gecode sequence() constraint by limiting the value\n    set to 1. This version is provided here for compatibility with IC and \n    FD, where the more general sequence/5 constraint is implemented on top\n    of this more restrictive sequence/4.\n</P>\n")]).
:- comment(sequence / 5, [template : "<ConsistencyModule:> sequence(+Low,+High,+K,+Vars,++Values)", amode : sequence(+, +, +, +, ++), args : ["Low" : "Non-negative integer", "High" : "Positive integer", "K" : "Positive integer", "Vars" : "A list of variables or integers", "Values" : "A list of (different) integers"], summary : "The number of values taken from Values is between Low and High for all sequences of K variables in Vars.", see_also : [sequence / 4, _102399 : sequence / 5], kind : [constraint : [extra : [gccat : among_seq]]], eg : "\n[eclipse 22]: sequence(1,2,4,[9,2,4,5,5,7,2], [0,2,4,6,8]). % Succeed\n\n", desc : html("<P>\n    This constraint ensures that the number of values taken from the set\n    specified in Values is at least Low and at most High for all sequences \n    of K consecutive variables/values in Vars. \n</P><P>\n    ConsistencyModule is the optional module specification to give the \n    consistency level for the propagation for this constraint: \n    gfd_gac for generalised arc consistency (domain consistency). \n</P><P>\n    This constraint is known as among_seq in the global constraint catalog,\n    and is implemented using Gecode's sequence() constraint.\n</P>\n")]).
:- comment(sorted / 2, [summary : "Sorted is a sorted permutation of Unsorted", amode : sorted(+, +), amode : sorted(+, -), amode : sorted(-, +), template : "<ConsistencyModule:> sorted(?Unsorted, ?Sorted)", args : ["Unsorted" : "List or collection of N domain variables or integers", "Sorted" : "List or collection of N domain variables or integers"], kind : [constraint : [extra : [gccat : sort]]], eg : "\n[eclipse 2]: sorted([1,9,1,5,2|L], [1,1,1,2,5,9]).\n\nL = [1]\n\n[eclipse 3]:  sorted([1,9,1,5,2,1], S).\n\nS = [1, 1, 1, 2, 5, 9]\n\n[eclipse 4]: length(Xs,4), Xs::0..100, sorted(Xs,Ys), Xs = [8,20|_].\n\nXs = [8, 20, _694{[0 .. 100]}, _714{[0 .. 100]}]\nYs = [_774{[0 .. 8]}, _794{[0 .. 20]}, _814{[8 .. 100]}, _834{[20 .. 100]}]\n\n[eclipse 5]: length(Ys,4), Ys::0..100, sorted(Xs,Ys), Ys = [8,20|_].\n\nYs = [8, 20, _694{[20 .. 100]}, _714{[20 .. 100]}]\nXs = [_832{[8 .. 100]}, _852{[8 .. 100]}, _872{[8 .. 100]}, _892{[8 .. 100]}]\n\n    ", desc : html("    Declaratively: The two lists (or collections) have the same length\n    and Sorted is a sorted permutation of Unsorted.\n<P>\n    Operationally:  the elements in both collections are constrained such\n    that their domains are consistent with the assumption that Sorted\n    is the sorted version of Unsorted.\n<P>\n    One of the two arguments can be uninstantiated or partial lists\n    at call time.\n<P>\n    Any input variables which is not already a domain variable will be\n    turned into a domain variable with default bounds.\n<P>\n    ConsistencyModule is the optional module specification to give the \n    consistency level for the propagation for this constraint: \n    gfd_bc for bounds consistency.\n<P>\n    This constraint is known as sort in the global constraint catalog,\n    and is implemented using Gecode's sorted() constraint.\n<P>\n"), see_also : [_56187 : sorted / 2, sorted / 3, ordered / 2]]).
:- comment(sorted / 3, [summary : "Sorted is a sorted permutation (described by Positions) of Unsorted", amode : sorted(+, ?, ?), amode : sorted(?, +, ?), amode : sorted(?, ?, +), template : "<ConsistencyModule:> sorted(?Unsorted, ?Sorted, ?Positions)", args : ["Unsorted" : "Collection of N domain variables or integers", "Sorted" : "Collection of N domain variables or integers", "Positions" : "Collection of N domain variables or integers"], kind : [constraint : [extra : [gccat : sort_permutation]]], desc : html("    Declaratively:  Sorted is a sorted permutation of Unsorted.  Positions\n    is a collection whose elements range from 1 to N (where N is the \n    cardinality of the collections) indicating the position of each \n    unsorted list element within the sorted list.  The positions are all \n    different. The three collections are constrained to have the same size.\n<P>\n    Operationally:  the elements in all three collections are constrained\n    such that their domains are consistent with the declarative\n    meaning.\n<P>\n    Two of the three arguments can be uninstantiated or partial lists\n    at call time.\n<P>\n    Any input variables which is not already a domain variable will be\n    turned into a domain variable with default bounds.\n<P>\n   Note that the gecode implementation of the constraint use \n   positions starting from 0. An extra dummy element smaller than all\n   the elements in List is added so that the position returned correspond\n   to the usual ECLiPSe index starting from 1. In addition, the complexity\n   of the algorithm used by gecode is linear in time with respect to \n   Max - Min, where Max and Min are the Maximum and Minimum possible values\n   for elements in List, respectively. Therefore, this constraint will \n   behave badly for variables with large domain widths. For a version of this\n   constraint that uses native Gecode indexing, see sorted_g/3.\n<P>\n    ConsistencyModule is the optional module specification to give the \n    consistency level for the propagation for this constraint: \n    gfd_bc for bounds consistency.\n<P>\n    This constraint is known as sort_permutation in the global\n    constraint catalog, and is implemented using Gecode's sorted() constraint.\n"), eg : "\n[eclipse 2]: length(Xs,4),Xs :: 1 .. 100,sorted(Xs, Ys, Ps),Xs = [8, 20|_].\n\nXs = [8, 20, _715{[1 .. 100]}, _735{[1 .. 100]}]\nYs = [_804{[1 .. 8]}, _824{[1 .. 20]}, _844{[8 .. 100]}, _864{[20 .. 100]}]\nPs = [_969{[1 .. 3]}, _989{[2 .. 4]}, _1009{[1 .. 4]}, _1029{[1 .. 4]}]\n\n    ", see_also : [_57561 : sorted / 3, sorted / 2, ordered / 2, sorted_g / 3]]).
:- comment(sorted_g / 3, [summary : "Sorted is a sorted permutation (described by Positions) of Unsorted, with native Gecode indexing.", amode : sorted_g(+, ?, ?), amode : sorted_g(?, +, ?), amode : sorted_g(?, ?, +), template : "<ConsistencyModule:> sorted_g(?Unsorted, ?Sorted, ?Positions)", args : ["Unsorted" : "Collection of N domain variables or integers", "Sorted" : "Collection of N domain variables or integers", "Positions" : "Collection of N domain variables or integers"], see_also : [sorted / 3], kind : [constraint : [extra : [gccat : sort_permutation]]], desc : html("  This version of sorted/3 uses the native Gecode indexing, which starts \n  from 0, i.e. the first element of the collections has index 0. This is \n  different from normal ECLiPSe's indexing, which starts from 1.\n</p><p>\n  This predicate maps more directly to Gecode's native implementation of \n  the constraint, without the conversion between Gecode and ECLiPSe\n  indexing of sorted/3. It may therefore be more efficient, but could also\n  be incompatible with existing ECLiPSe code. \n</p><p>\n  See sorted/3 for a more detailed description of this predicate.")]).
:- comment(sum / 2, [summary : "The sum (Collection) or scalar product (IntCollection*Collection) of the Collection elements is Sum", template : "<ConsistencyModule:> sum(+Collection,?Sum)", amode : sum(+, ?), args : ["Collection or Coeffs*Collection" : "Collection: collection of N integers or domain variables. Coeffs: collection of N integers.", "Sum" : "Variable or integer"], see_also : [sumlist / 2, _25276 : sum / 2], kind : [constraint : [extra : [gccat : sum_ctr]]], desc : html("<P>          Constrains Sum to be the sum of the elements in Collection if\n          the first argument is a collection of integers or domain variables.\n\t  </P><P>\n          Constrains Sum to be the scalar product of a collection of integers \n          and a collection of integers or domain variables if the first\n          argument is Coeffs*Collection. Coeffs and Collection\n          must have the same number of elements, and the scalar product \n          is the sum of the coefficients in Coeffs with the corresponding\n          element in Collection.\n\t  </P><P>\n\t  Any input variables which are not already domain variable will be\n          turn into domain variables with default bounds.</P><P>\n\t  </P><P>\n          You may find it more convenient to embed <TT>sum(Vars)</TT> in a\n          constraint expression.\n\t  </P><P>\n          ConsistencyModule is the optional module specification to give the \n          consistency level for the propagation for this constraint: \n          gfd_bc for bounds consistency, and \n          gfd_gac for domain (generalised arc) consistency.\n          </P><P>\n          This constraint is known as sum_ctr (with the = relation) in the\n          global constraint catalog, and is implemented using Gecode's\n          linear() constraint (with IRT_EQ relation).\n          </P>\n")]).
:- comment(sum / 3, [summary : "Constrains the sum of the elements of Collection to satisfy the relation sum(Collection) Rel Sum.", template : "<ConsistencyModule:> sum(+Collection,+Rel,?Sum)", amode : sum(+, +, ?), args : ["Collection" : "Collection of integers or domain variables.", "RelOp" : "One of the atom: #>, #>=, #<, #=<, #=, #\\=", "Sum" : "Variable or integer"], kind : [constraint : [extra : [gccat : sum_ctr]]], see_also : [sum / 4], desc : html("<P>          Constrains the sum of the elements in Collection to satisfy\n          the relation sum(Collection) Rel Sum.\n\t  </P><P>\n          Rel can be one of #&gt;, #&gt;=, #&lt;, #=&lt;, #=, #\\= (or equivalently,\n          &gt;, &gt;=, &lt;, =&lt;, =, \\=).\n\t  </P><P>\n\t  Any input variables which are not already domain variable will be\n          turn into domain variables with default bounds.</P><P>\n\t  </P><P>\n          You may find it more convenient to embed <TT>sum(Collections,RelOp)</TT> \n          in a constraint expression.\n\t  </P><P>\n          ConsistencyModule is the optional module specification to give the \n          consistency level for the propagation for this constraint: \n          gfd_bc for bounds consistency, and \n          gfd_gac for domain (generalised arc) consistency.\n          </P><P>\n          Domain consistency is different from bounds consistency only if\n          Rel is #=.\n          </P><P>\n          This constraint is known as sum_ctr in the global constraint \n          catalog, and is implemented using Gecode's linear() constraint.\n          </P>\n    ")]).
:- comment(sum / 4, [summary : "Reflect into Bool the truth of the sum of the elements of Collection satisfying the relation sum(Collection) Rel Sum.", template : "<ConsistencyModule:> sum(+Collection,+Rel,?Sum,?Bool)", amode : sum(+, +, ?, ?), args : ["Collection" : "Collection of integers or domain variables.", "RelOp" : "One of the atom: #>, #>=, #<, #=<, #=, #\\=", "Sum" : "Variable or integer", "Bool" : "Variable or the integer 0 or 1"], kind : [constraint], see_also : [sum / 3], desc : html("<P>          This is the reified form of sum/3, which constrains the sum\n          of  the elements in Collection to satisfy the relation \n          sum(Collection) Rel Sum.\n\t  </P><P>\n          Rel can be one of #&gt;, #&gt;=, #&lt;, #=&lt;, #=, #\\= (or equivalently,\n          &gt;, &gt;=, &lt;, =&lt;, =, \\=).\n\t  </P><P>\n\t  Any input variables which are not already domain variable will be\n          turn into domain variables with default bounds.</P><P>\n\t  </P><P>\n          ConsistencyModule is the optional module specification to give the \n          consistency level for the propagation for this constraint: \n          gfd_bc for bounds consistency \n          </P><P>\n          This constraint is implemented using Gecode's linear() constraint\n          (reified version).\n          </P>\n    ")]).
:- comment(sumlist / 2, [summary : "The sum (Collection) or scalar product (IntCollection*Collection) of the Collection elements is Sum", template : "<ConsistencyModule:> sumlist(+Collection,?Sum)", amode : sumlist(+, ?), args : ["Collection or Coeffs*Collection" : "Collection: collection of N integers or domain variables. Coeffs: collection of N integers.", "Sum" : "Variable or integer"], see_also : [_26303 : sumlist / 2], kind : [constraint : [extra : [gccat : sum_ctr]]], desc : html("<P>   An alias for sum/2. provided for consistency.</P>\n\n   You may find it more convenient to embed <TT>sumlist(Vars)</TT> in a\n   constraint expression.\n")]).
:- comment(table / 2, [template : "<ConsistencyModule:> table(+Vars, ++Table)", summary : "Constrain Vars' solutions to be those defined by the tuples in Table.", amode : table(+, ++), args : ["Vars" : "Collection of N domain variables or integers,\n or a collection of a collection of N domain variables or integers.", "Table" : "Collection of tuples, each of which is a collection\n of N integer values"], kind : [constraint : [extra : [gccat : in_relation]]], eg : "\n[eclipse 9]: table([5,3,3], [[](5,2,3),[](5,2,6),[](5,3,3)]).  % succeed\n                                                               \n[eclipse 10]:  table([[5,3,3],[5,2,3]],  \n                     [[](5,2,3),[](5,2,6),[](5,3,3)]).         % succeed\n\n[eclipse 11]: table([5,3,2], [[](5,2,3),[](5,2,6),[](5,3,3)]). % fail\n\n[eclipse 12]: L = [A,B,C], table(L, [[](5,2,3),[](5,2,6),[](5,3,3)]), \n        labeling(L), writeln(L), fail.\n[5, 2, 3]\n[5, 2, 6]\n[5, 3, 3]\n\nNo (0.00s cpu)\n\n", see_also : [table / 3], desc : html("   table is an extensional constraint or user defined constraint, i.e.\n   the solutions for the each posted constraint is explicitly defined within \n   the constraint. Each table constraint specifies the solutions to N\n   variables, with all the solutions for this constraint specified in Table,\n   in the form of tuples, each of N values that is one solution to the\n   constraint. \n</p><p>\n   Vars represents the variables that are to be satisfied for this\n   constraint. It can be one collection of N variables (or integers),\n   or a collection of a collections of N variables (or integers), if\n   the constraint is to be satisfied by more than one collection of \n   variables. Posting the constraint with multiple collections of \n   variables is logically equivalent to posting individual table\n   constraint with the same Table for each collection, but should be\n   more efficient as the same Table is shared by all the collections.\n</p><p>\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_gac for generalised arc consistency (domain consistency).\n</p><p>\n   This constraint is known as in_relation in the global constraint catalog, \n   with the allowance for multiple collections of variables taken from\n   SICStus Prolog's table/2 constraint. This constraint is implemented in\n   Gecode as the extensional() constraint with the variant that takes a\n   TupleSet as an argument.\n</p>\n")]).
:- comment(table / 3, [template : "<ConsistencyModule:> table(+Vars, ++Table, +Option)", summary : "Constrain Vars' solutions to be those defined by the tuples in Table.", amode : table(+, ++, +), args : ["Vars" : "Collection of N domain variables or integers,\n or a collection of a collection of N domain variables or integers.", "Table" : "Collection of tuples, each of which is a collection\n of N integer values", "Option" : "the atom 'mem' or 'speed' or 'default'"], kind : [constraint : [extra : [gccat : in_relation]]], eg : "\n[eclipse 9]: table([5,3,3], [[](5,2,3),[](5,2,6),[](5,3,3)], speed).  % succeed\n                                                               \n[eclipse 10]: table([[5,3,3],[5,2,3]],  \n                     [[](5,2,3),[](5,2,6),[](5,3,3)], default).       % succeed\n\n[eclipse 11]: table([5,3,2], [[](5,2,3),[](5,2,6),[](5,3,3)], mem).   % fail\n\n", see_also : [table / 2], desc : html("   table is a user defined constraint, i.e. the solutions for the each \n   posted constraint is explicitly defined within the constraint. Each \n   table constraint specifies the solutions to N variables, with all\n   the solutions for this constraint specified in Table, in the form\n   of tuples, each of N values that is one solution to the constraint. \n</p><p>\n   Vars represents the variables that are to be satisfied for this\n   constraint. It can be one collection of N variables (or integers),\n   or a collection of a collections of N variables (or integers), if\n   the constraint is to be satisfied by more than one collection of \n   variables. Posting the constraint with multiple collections of \n   variables is logically equivalent to posting individual table\n   constraint with the same Table for each collection, but should be\n   more efficient as the same Table is shared by all the collections.\n</p><p>\n   Option currently allows the selection of algorithm to use for the \n   propagation: mem for an algorithm that prefer smaller memory\n   consumption over amount of  computation, speed for an algorithm that\n   prefer reducing computation over memory consumption, and default\n   for the default algorithm (as defined by Gecode). Note that table/2\n   is mapped to table/3 with Option set to default.\n</p><p>\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_gac for generalised arc consistency (domain consistency).\n</p><p>\n   This constraint is known as in_relation in the global constraint catalog, \n   with the allowance for multiple collections of variables taken from\n   SICStus Prolog's table/2 constraint. This constraint is implemented in\n   Gecode as the extensional() constraint with the variant that takes a\n   TupleSet as an argument.\n</p>\n")]).
:- comment(try_value / 2, [summary : "Two-way and multi-way choice predicate", amode : (try_value(?, ++) is nondet), amode : (try_value(+, ++) is det), args : ["Var" : "a domain variable or an integer", "Method" : "an atom denoting the value choice method"], kind : [search], desc : html("<P>\n    This search predicate makes a choice on the domain of the variable.\n    This choice can be a binary choice, or an indomain style multi-way\n    choice which branches on different values in the domain of the variable.\n</P><P>\n    The binary choice methods create two search alternatives, which \n    reduce the variable domain  in complementary ways.  The details\n    are determined by the Method.\n</P><P>\n    The first group of binary methods tries to set the variable to a \n    particular value, and in the alternative excludes this value from \n    the domain, logically:\n<PRE>\n\t( Var = Value ; Var #\\= Value )\n</PRE>\n<DL>\n    <DT>min</DT>\n\t<DD>try the minimum value in the domain</DD>\n    <DT>max</DT>\n\t<DD>try the maximum value in the domain</DD>\n    <DT>median</DT>\n\t<DD>try the median value in the domain</DD>\n</DL>\n    The next binary group only halves the domain in each alternative (where\n    the split value is the arithmetic mean of the lower and upper domain\n    bound, rounded down):\n<PRE>\n\t( Var #=&lt; Split ; Var #&gt; Split )\n</PRE>\n<DL>\n    <DT>split</DT>\n\t<DD>try first the lower domain half, then the upper</DD>\n    <DT>reverse_split</DT>\n\t<DD>try first the upper domain half, then the lower</DD>\n</DL>\n    The indomain style group choses an initial value from the variable's\n    domain of according to the given method, and on backtracking \n    select other values in the domain. \n<DL>\n    <DT>indomain_min</DT>\n\t<DD>Values are tried in increasing order.</DD>\n    <DT>indomain_max</DT>\n\t<DD>Values are tried in decreasing order.</DD>\n    <DT>indomain_median</DT>\n\t<DD>Values are tried starting from the median value of the \n        domain, then alternately the next larger and smaller values \n        in the domain.</DD>\n    <DT>indomain_middle</DT>\n\t<DD>Values are tried starting from  the middle of the range\n        (which does not need to be in domain), then alternately the\n         next larger and smaller values in the domain.</DD>\n    <DT>indomain_from(+Val)</DT>\n\t<DD>Values are tried starting from  Val (which does not need\n        to be in domain), then alternately the next larger and smaller \n        values in the domain.</DD>\n</DL> \n</P><P>\n    As opposed to the value choice predicates indomain/1 and indomain/2,\n    the binary choice methods of try_value/2 does not necessarily \n    instantiate the variable.  If used in a tree search, this means\n    that the variable must remain available to the variable selection,\n    as it may be selected repeatedly at different depth of the search\n    tree.\n</P><P>\n    The indomain style methods do instantiate the variable. If used in\n    a tree search, try_value represents a n-ary choice for all the\n    values of a variable. In this case, the maximum depth of the\n    search-tree is the number of probem variables. \n</P><P>\n    This predicate should be more efficient than using generic value\n    choice predicates or explicitly writing code to do the choice. The\n    exclusion of values before a new choice is done by specialised\n    low-level primitves that are more efficient than user-level\n    constraints. This efficiency is particularly important because\n    they make recomputation more efficient. For the binary choice\n    methods, the exclusion of values are performed in every\n    recomputation of the choice; and for the indomain style methods,\n    the old values are excluded from the variable's domain to allow\n    the next value to be chosen. On recomputation, the variable is\n    directly set to the chosem value.  This reduces the amount of\n    recomputation, but any reduction in the search space resulting\n    from propagating rhe exclusion of old values may also be lost.\n</P><P>\n    try_value/2 is best used in combination with select_var/5. Both can\n    be used to parameterise the generic gfd_search:search/6 procedure.\n</P>"), eg : "\n    % Used with generic search/6\n    gfd_search:search(Xs,0,select_var(first_fail),try_value(min),complete,[]).\n\n\n    % Simple labelling implemented using select_var/5 and try_value/2\n    labelling(Vars, Select, Choice) :-\n        (select_var(V, Vars, Rest, 0, Select) ->\n            try_value(V, Choice),\n            labelling(Rest, Select, Choice)\n        ;\n            true\n        ).\n"]).
:- comment(xor / 2, [amode : xor(+, +), template : "<ConsistencyModule:> +ConX xor +ConY", args : ["ConX" : "Constraint", "ConY" : "Constraint"], summary : "One of the constraints ConX or ConY must be true.", see_also : [xor / 3, neg / 1, or / 2, and / 2, => / 2, <=> / 2, _37513 : (#\=) / 2], kind : [constraint], desc : html("<P>\n   Equivalent to BX #= (ConX), BY #= (ConY), BX + BY #= 1</P>\n   <P>\n   The two constraints are reified in such a way that one and only one must be\n   true.  ConX and ConY must be constraints that have a corresponding\n   reified form.<P></P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. \n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P>\n")]).
:- comment(xor / 3, [amode : xor(+, +, ?), template : "<ConsistencyModule:> xor(+ConX,+ConY,Bool)", args : ["ConX" : "Constraint", "ConY" : "Constraint", "Bool" : "Reified truth value of the constraint"], summary : "Bool is the reified truth of one of the constraints ConX or ConY being true.", see_also : [or / 2, neg / 2, and / 3, xor / 3, => / 3, <=> / 3, (=<) / 3, _38587 : (#\=) / 3], kind : [constraint : [extra : [gccat : xor]]], desc : html("<P>\n   Equivalent to BX #= (ConX), BY #= (ConY), Bool #= (BX + BY #= 1)</P>\n   <P>\n   The two constraints are reified in such a way that Bool reflects the\n   truth of one (and only one) being true.  ConX and ConY must be \n   constraints that have a corresponding reified form.<P></P>\n\n   ConsistencyModule is the optional module specification to give the \n   consistency level for the propagation for this constraint: \n   gfd_bc for bounds consistency, and gfd_gac for domain (generalised arc) \n   consistency. \n</P><P>\n   This constraint is implemented using Gecode's MiniModel's rel() for\n   both integer and boolean expressions, with sub-expressions/constraints\n   not supported by MiniModel factored out and posted as auxiliary \n   constraints.\n</P><P>\n   A more restricted version of this constraint is defined in the \n   global constraint catalog as 'xor', in that the reified truth value\n   is the logical exclusive disjunction of 0/1 variables rather than \n   constraints.\n</P>\n")]).
